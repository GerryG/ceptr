<style type="text/css">table.processes ol{margin:0;padding:1em;}</style>
<table class="doxtable processes"><tr><th>Process</th><th>Children (inputs)</th><th>Reduces To (output)</th><th>Comments</th></tr>
<tr><td><a name="NOOP"></a>NOOP</td><td><ol><li>do(ANY:<a href="ref_sys_symbols.html#NULL_STRUCTURE">NULL_STRUCTURE</a>)</li></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>no-op</i><br />   this process reduces to its single "do" parameter.</td></tr>
<tr><td><a name="GET"></a>GET</td><td><ol><li>what(SYMBOL:<a href="ref_sys_symbols.html#GET_XADDR">GET_XADDR</a>)</li></ol></td><td>value(ANY:<a href="ref_sys_symbols.html#NULL_STRUCTURE">NULL_STRUCTURE</a>)</td><td><i>get instance value</i><br />   reduces to the value of the instance at the xaddr of the "what" parameter</td></tr>
<tr><td><a name="IF"></a>IF</td><td><ol><li>condition(PROCESS:<a href="ref_sys_symbols.html#BOOLEAN">BOOLEAN</a>)</li><li>then(ANY:<a href="ref_sys_symbols.html#NULL_STRUCTURE">NULL_STRUCTURE</a>)</li><li>[else(ANY:<a href="ref_sys_symbols.html#NULL_STRUCTURE">NULL_STRUCTURE</a>)]</li></ol></td><td>result(PASSTHRU:<a href="ref_sys_symbols.html#NULL_STRUCTURE">NULL_STRUCTURE</a>)</td><td><i>if</i><br />  this is a traditional "if" process that reduces conditionally to either the "then" or the "else" parameter depending on the value of the "condition" parameter.  Note: we may be replacing this with a more lispy COND process</td></tr>
<tr><td><a name="ITERATE"></a>ITERATE</td><td><ol><li>condtion(PROCESS:<a href="ref_sys_symbols.html#BOOLEAN">BOOLEAN</a>)</li><li>do(ANY:<a href="ref_sys_symbols.html#NULL_STRUCTURE">NULL_STRUCTURE</a>)</li></ol></td><td>result(PASSTHRU:<a href="ref_sys_symbols.html#NULL_STRUCTURE">NULL_STRUCTURE</a>)</td><td><i>iterate a process</i><br />                     this process checks the structure of the result of the "condition" param, if it's a BOOLEAN, it treats the iteration as a while loop and iterates until the BOOLEAN is false; if it's an INTEGER it treats the iteration as repeat loop and iterates as many times as the value of the INTEGER</td></tr>
<tr><td><a name="SAY"></a>SAY</td><td><ol><li>to(SYMBOL:<a href="ref_sys_symbols.html#RECEPTOR_ADDRESS">RECEPTOR_ADDRESS</a>)</li><li>on(SYMBOL:<a href="ref_sys_symbols.html#ASPECT">ASPECT</a>)</li><li>message(ANY:<a href="ref_sys_symbols.html#NULL_STRUCTURE">NULL_STRUCTURE</a>)</li></ol></td><td>error(SYMBOL:<a href="ref_sys_symbols.html#REDUCTION_ERROR_SYMBOL">REDUCTION_ERROR_SYMBOL</a>)</td><td><i>send a message to a receptor</i></td></tr>
<tr><td><a name="REQUEST"></a>REQUEST</td><td><ol><li>of(SYMBOL:<a href="ref_sys_symbols.html#RECEPTOR_ADDRESS">RECEPTOR_ADDRESS</a>)</li><li>on(SYMBOL:<a href="ref_sys_symbols.html#ASPECT">ASPECT</a>)</li><li>message(ANY:<a href="ref_sys_symbols.html#NULL_STRUCTURE">NULL_STRUCTURE</a>)</li><li>respond on(SYMBOL:<a href="ref_sys_symbols.html#RESPONSE_CARRIER">RESPONSE_CARRIER</a>)</li><li>[until(SYMBOL:<a href="ref_sys_symbols.html#REQUEST_CONDITIONS">REQUEST_CONDITIONS</a>)]</li><li>[callback(PROCESS:<a href="ref_sys_symbols.html#NULL_SYMBOL">NULL_SYMBOL</a>)]</li></ol></td><td>response(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>send a request to a receptor</i><br />  if there is no "callback" param, then this process will block until the result comes back or the "until" causes cleanup of pending request.</td></tr>
<tr><td><a name="LISTEN"></a>LISTEN</td><td><ol><li>listen for(SYMBOL:<a href="ref_sys_symbols.html#EXPECTATION">EXPECTATION</a>)</li><li>on(SYMBOL:<a href="ref_sys_symbols.html#CARRIER">CARRIER</a>)</li><li>with(SYMBOL:<a href="ref_sys_symbols.html#PARAMS">PARAMS</a>)</li><li>do(SYMBOL:<a href="ref_sys_symbols.html#ACTION">ACTION</a>)</li></ol></td><td>error(SYMBOL:<a href="ref_sys_symbols.html#REDUCTION_ERROR_SYMBOL">REDUCTION_ERROR_SYMBOL</a>)</td><td><i>plant a listener</i></td></tr>
<tr><td><a name="RESPOND"></a>RESPOND</td><td><ol><li>response contents(ANY:<a href="ref_sys_symbols.html#NULL_STRUCTURE">NULL_STRUCTURE</a>)</li></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>respond to signal</i></td></tr>
<tr><td><a name="EXPECT_ACT"></a>EXPECT_ACT</td><td><ol><li>on(SYMBOL:<a href="ref_sys_symbols.html#CARRIER">CARRIER</a>)</li><li>expectation(STRUCTURE:<a href="ref_sys_symbols.html#SEMTREX">SEMTREX</a>)</li><li>with(SYMBOL:<a href="ref_sys_symbols.html#PARAMS">PARAMS</a>)</li><li>do(PROCESS:<a href="ref_sys_symbols.html#QUOTE">QUOTE</a>)</li></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>block run tree until expectation met and then act</i><br />     This process is different from LISTEN in that it blocks the current process until an expectation is matched, at which point the excecution context resumes.  It's also broken in that the current CARRIER isn't real, it takes a c pointer. This process may be obsolete and folded in with LISTEN.</td></tr>
<tr><td><a name="QUOTE"></a>QUOTE</td><td><ol></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>quote a process so that it can be passed as a value</i></td></tr>
<tr><td><a name="INTERPOLATE_FROM_MATCH"></a>INTERPOLATE_FROM_MATCH</td><td><ol></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>interploate match result in place</i></td></tr>
<tr><td><a name="RAISE"></a>RAISE</td><td><ol></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>raise reduction error</i></td></tr>
<tr><td><a name="STREAM_READ"></a>STREAM_READ</td><td><ol></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>read from a stream</i></td></tr>
<tr><td><a name="STREAM_WRITE"></a>STREAM_WRITE</td><td><ol></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>write to a stream</i></td></tr>
<tr><td><a name="STREAM_ALIVE"></a>STREAM_ALIVE</td><td><ol></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>check a stream is alive for reading</i></td></tr>
<tr><td><a name="CONCAT_STR"></a>CONCAT_STR</td><td><ol></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>concatinate strings</i></td></tr>
<tr><td><a name="ADD_INT"></a>ADD_INT</td><td><ol><li>augend(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</li><li>addend(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</li></ol></td><td>sum(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</td><td><i>addition</i></td></tr>
<tr><td><a name="SUB_INT"></a>SUB_INT</td><td><ol><li>minuend(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</li><li>subtrahend(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</li></ol></td><td>difference(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</td><td><i>subtract</i></td></tr>
<tr><td><a name="MULT_INT"></a>MULT_INT</td><td><ol><li>multiplicand(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</li><li>multiplier(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</li></ol></td><td>product(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</td><td><i>multiply</i></td></tr>
<tr><td><a name="DIV_INT"></a>DIV_INT</td><td><ol><li>dividend(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</li><li>divisor(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</li></ol></td><td>quotient(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</td><td><i>divide</i></td></tr>
<tr><td><a name="MOD_INT"></a>MOD_INT</td><td><ol><li>dividend(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</li><li>divisor(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</li></ol></td><td>remainder(STRUCTURE:<a href="ref_sys_symbols.html#INTEGER">INTEGER</a>)</td><td><i>modulo</i></td></tr>
<tr><td><a name="EQ_INT"></a>EQ_INT</td><td><ol></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>test equality</i></td></tr>
<tr><td><a name="LT_INT"></a>LT_INT</td><td><ol></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>test less than</i></td></tr>
<tr><td><a name="GT_INT"></a>GT_INT</td><td><ol></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>test greater than</i></td></tr>
<tr><td><a name="LTE_INT"></a>LTE_INT</td><td><ol></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>test less than or equal</i></td></tr>
<tr><td><a name="GTE_INT"></a>GTE_INT</td><td><ol></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>test greater than or equal</i></td></tr>
<tr><td><a name="SPECIAL"></a>SPECIAL</td><td><ol></ol></td><td>result(STRUCTURE:<a href="ref_sys_symbols.html#TREE">TREE</a>)</td><td><i>dark magic</i><br />   this process reduces to hardcoded special things as a scaffold for things we don't know how to build in ceptr yet.</td></tr>
</table>
