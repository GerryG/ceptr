\hypertarget{tree_8c}{\section{src/tree.c File Reference}
\label{tree_8c}\index{src/tree.\+c@{src/tree.\+c}}
}


Semantic trees are the basic data building block for ceptr.  


{\ttfamily \#include \char`\"{}tree.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}ceptr\+\_\+error.\+h\char`\"{}}\\*
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{tree_8c_aa4892b9d7c5e5cc3c167c9d926ad0bfb}{void {\bfseries \+\_\+\+\_\+t\+\_\+append\+\_\+child} (\hyperlink{structTnode}{Tnode} $\ast$t, \hyperlink{structTnode}{Tnode} $\ast$c)}\label{tree_8c_aa4892b9d7c5e5cc3c167c9d926ad0bfb}

\item 
\hypertarget{tree_8c_a558ed27a40e82d2a51c8076e09f86ea5}{void {\bfseries \+\_\+\+\_\+t\+\_\+init} (\hyperlink{structTnode}{Tnode} $\ast$t, \hyperlink{structTnode}{Tnode} $\ast$parent, Symbol symbol)}\label{tree_8c_a558ed27a40e82d2a51c8076e09f86ea5}

\item 
\hypertarget{tree_8c_a3e4d21716053b7ff441109306742b9cd}{\hyperlink{structTnode}{Tnode} $\ast$ {\bfseries \+\_\+t\+\_\+new} (\hyperlink{structTnode}{Tnode} $\ast$parent, Symbol symbol, void $\ast$surface, size\+\_\+t size)}\label{tree_8c_a3e4d21716053b7ff441109306742b9cd}

\item 
\hypertarget{tree_8c_ab438eeedb3eb6c1e20171b33d8ec499d}{\hyperlink{structTnode}{Tnode} $\ast$ {\bfseries \+\_\+t\+\_\+newi} (\hyperlink{structTnode}{Tnode} $\ast$parent, Symbol symbol, int surface)}\label{tree_8c_ab438eeedb3eb6c1e20171b33d8ec499d}

\item 
\hypertarget{tree_8c_a32d63b4eed14670dd96c8cf9d293de52}{\hyperlink{structTnode}{Tnode} $\ast$ {\bfseries \+\_\+t\+\_\+newt} (\hyperlink{structTnode}{Tnode} $\ast$parent, Symbol symbol, \hyperlink{structTnode}{Tnode} $\ast$surface)}\label{tree_8c_a32d63b4eed14670dd96c8cf9d293de52}

\item 
\hypertarget{tree_8c_a17676267c6fb457dd1d086f37641544a}{\hyperlink{structTnode}{Tnode} $\ast$ {\bfseries \+\_\+t\+\_\+new\+\_\+root} (Symbol symbol)}\label{tree_8c_a17676267c6fb457dd1d086f37641544a}

\item 
\hypertarget{tree_8c_aff88720dad09389f6b7f35f7985d8efd}{\hyperlink{structTnode}{Tnode} $\ast$ {\bfseries \+\_\+t\+\_\+newr} (\hyperlink{structTnode}{Tnode} $\ast$parent, Symbol symbol)}\label{tree_8c_aff88720dad09389f6b7f35f7985d8efd}

\item 
\hypertarget{tree_8c_af155629f920b45c8b3d11bb19255d69e}{void {\bfseries \+\_\+t\+\_\+add} (\hyperlink{structTnode}{Tnode} $\ast$t, \hyperlink{structTnode}{Tnode} $\ast$c)}\label{tree_8c_af155629f920b45c8b3d11bb19255d69e}

\item 
\hyperlink{structTnode}{Tnode} $\ast$ \hyperlink{tree_8c_a302facc6d6e2d4937d560e081c828095}{\+\_\+t\+\_\+detach\+\_\+by\+\_\+idx} (\hyperlink{structTnode}{Tnode} $\ast$t, int i)
\item 
void \hyperlink{tree_8c_ab28a85eae18cd8b29c15ab535e312902}{\+\_\+t\+\_\+detach\+\_\+by\+\_\+ptr} (\hyperlink{structTnode}{Tnode} $\ast$t, \hyperlink{structTnode}{Tnode} $\ast$c)
\item 
void \hyperlink{tree_8c_adbb495c31450fbe199aa913ecb77eed2}{\+\_\+\+\_\+t\+\_\+morph} (\hyperlink{structTnode}{Tnode} $\ast$t, Symbol s, void $\ast$surface, size\+\_\+t size, int allocate)
\item 
void \hyperlink{tree_8c_a91798c3f4945bb89b9c13e9b693ffd78}{\+\_\+t\+\_\+morph} (\hyperlink{structTnode}{Tnode} $\ast$dst, \hyperlink{structTnode}{Tnode} $\ast$src)
\item 
void \hyperlink{tree_8c_a571dd95ead249012211ffe5d180f56ec}{\+\_\+t\+\_\+replace} (\hyperlink{structTnode}{Tnode} $\ast$t, int i, \hyperlink{structTnode}{Tnode} $\ast$r)
\item 
\hypertarget{tree_8c_a2a7dd3d550c979c77e5fd5bb98310b54}{void {\bfseries \+\_\+\+\_\+t\+\_\+free\+\_\+children} (\hyperlink{structTnode}{Tnode} $\ast$t)}\label{tree_8c_a2a7dd3d550c979c77e5fd5bb98310b54}

\item 
\hypertarget{tree_8c_ac9311eb831d86ab8395f9c1c81f584d9}{void {\bfseries \+\_\+t\+\_\+free} (\hyperlink{structTnode}{Tnode} $\ast$t)}\label{tree_8c_ac9311eb831d86ab8395f9c1c81f584d9}

\item 
\hypertarget{tree_8c_a43217c1463568d02942703196b3a6428}{\hyperlink{structTnode}{Tnode} $\ast$ {\bfseries \+\_\+\+\_\+t\+\_\+clone} (\hyperlink{structTnode}{Tnode} $\ast$t, \hyperlink{structTnode}{Tnode} $\ast$p)}\label{tree_8c_a43217c1463568d02942703196b3a6428}

\item 
\hypertarget{tree_8c_aaeb6a7d7bf14e958d9e79c699edb8040}{\hyperlink{structTnode}{Tnode} $\ast$ {\bfseries \+\_\+t\+\_\+clone} (\hyperlink{structTnode}{Tnode} $\ast$t)}\label{tree_8c_aaeb6a7d7bf14e958d9e79c699edb8040}

\item 
\hypertarget{tree_8c_af459b3de598bba95efe941c4960f845d}{int {\bfseries \+\_\+t\+\_\+children} (\hyperlink{structTnode}{Tnode} $\ast$t)}\label{tree_8c_af459b3de598bba95efe941c4960f845d}

\item 
\hypertarget{tree_8c_a5a292a02511c82863edfcaa72fa9698c}{void $\ast$ {\bfseries \+\_\+t\+\_\+surface} (\hyperlink{structTnode}{Tnode} $\ast$t)}\label{tree_8c_a5a292a02511c82863edfcaa72fa9698c}

\item 
\hypertarget{tree_8c_abfc4da7bf9475fb3bad4ea20b5f78fab}{Symbol {\bfseries \+\_\+t\+\_\+symbol} (\hyperlink{structTnode}{Tnode} $\ast$t)}\label{tree_8c_abfc4da7bf9475fb3bad4ea20b5f78fab}

\item 
\hypertarget{tree_8c_a4df2c885d019894bd8e14d2637639621}{size\+\_\+t {\bfseries \+\_\+t\+\_\+size} (\hyperlink{structTnode}{Tnode} $\ast$t)}\label{tree_8c_a4df2c885d019894bd8e14d2637639621}

\item 
\hypertarget{tree_8c_ab54b09e1a4cb708d81461e675d79143d}{\hyperlink{structTnode}{Tnode} $\ast$ {\bfseries \+\_\+t\+\_\+child} (\hyperlink{structTnode}{Tnode} $\ast$t, int i)}\label{tree_8c_ab54b09e1a4cb708d81461e675d79143d}

\item 
\hypertarget{tree_8c_a53f622542bf17af9d30ebd19aa339fe5}{\hyperlink{structTnode}{Tnode} $\ast$ {\bfseries \+\_\+t\+\_\+parent} (\hyperlink{structTnode}{Tnode} $\ast$t)}\label{tree_8c_a53f622542bf17af9d30ebd19aa339fe5}

\item 
\hypertarget{tree_8c_ab7560e5488d14cb6e04deb2f611144e2}{\hyperlink{structTnode}{Tnode} $\ast$ {\bfseries \+\_\+t\+\_\+root} (\hyperlink{structTnode}{Tnode} $\ast$t)}\label{tree_8c_ab7560e5488d14cb6e04deb2f611144e2}

\item 
\hypertarget{tree_8c_a0def9a39668c07f5553c1cf50238306e}{int {\bfseries \+\_\+t\+\_\+node\+\_\+index} (\hyperlink{structTnode}{Tnode} $\ast$t)}\label{tree_8c_a0def9a39668c07f5553c1cf50238306e}

\item 
\hypertarget{tree_8c_a49e337d9576c1f143e88a02aa9184756}{\hyperlink{structTnode}{Tnode} $\ast$ {\bfseries \+\_\+t\+\_\+next\+\_\+sibling} (\hyperlink{structTnode}{Tnode} $\ast$t)}\label{tree_8c_a49e337d9576c1f143e88a02aa9184756}

\item 
\hypertarget{tree_8c_a1d7afbc2a405c20a83b7bee4cfcb3a29}{int {\bfseries \+\_\+t\+\_\+path\+\_\+equal} (int $\ast$p1, int $\ast$p2)}\label{tree_8c_a1d7afbc2a405c20a83b7bee4cfcb3a29}

\item 
\hypertarget{tree_8c_a55270b512ed52ffe5a938a793fa5cd7f}{int {\bfseries \+\_\+t\+\_\+path\+\_\+depth} (int $\ast$p)}\label{tree_8c_a55270b512ed52ffe5a938a793fa5cd7f}

\item 
\hypertarget{tree_8c_a19a429819da9dcbc89ec7e259ef32db0}{int $\ast$ {\bfseries \+\_\+t\+\_\+get\+\_\+path} (\hyperlink{structTnode}{Tnode} $\ast$t)}\label{tree_8c_a19a429819da9dcbc89ec7e259ef32db0}

\item 
\hypertarget{tree_8c_a608555368dfdef7de1872f89b6fed637}{void {\bfseries \+\_\+t\+\_\+pathcpy} (int $\ast$dst\+\_\+p, int $\ast$src\+\_\+p)}\label{tree_8c_a608555368dfdef7de1872f89b6fed637}

\item 
\hypertarget{tree_8c_a47dee9789baa40961240b88369b633bc}{void {\bfseries \+\_\+t\+\_\+path\+\_\+parent} (int $\ast$n, int $\ast$p)}\label{tree_8c_a47dee9789baa40961240b88369b633bc}

\item 
\hypertarget{tree_8c_ad25dfd19f7a8ca955f32850fa867be0d}{\hyperlink{structTnode}{Tnode} $\ast$ {\bfseries \+\_\+t\+\_\+get} (\hyperlink{structTnode}{Tnode} $\ast$t, int $\ast$p)}\label{tree_8c_ad25dfd19f7a8ca955f32850fa867be0d}

\item 
\hypertarget{tree_8c_a1f03093882ea8ad3d6e88951e4fc51b5}{void $\ast$ {\bfseries \+\_\+t\+\_\+get\+\_\+surface} (\hyperlink{structTnode}{Tnode} $\ast$t, int $\ast$p)}\label{tree_8c_a1f03093882ea8ad3d6e88951e4fc51b5}

\item 
\hypertarget{tree_8c_a0e63c83e6413f47238db7fa20373c526}{char $\ast$ {\bfseries \+\_\+t\+\_\+sprint\+\_\+path} (int $\ast$fp, char $\ast$buf)}\label{tree_8c_a0e63c83e6413f47238db7fa20373c526}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Semantic trees are the basic data building block for ceptr. 

Everything in ceptr is built out of semantic trees. In ceptr all data is assumed to be meaningfull, not just structured. 

\subsection{Function Documentation}
\hypertarget{tree_8c_adbb495c31450fbe199aa913ecb77eed2}{\index{tree.\+c@{tree.\+c}!\+\_\+\+\_\+t\+\_\+morph@{\+\_\+\+\_\+t\+\_\+morph}}
\index{\+\_\+\+\_\+t\+\_\+morph@{\+\_\+\+\_\+t\+\_\+morph}!tree.\+c@{tree.\+c}}
\subsubsection[{\+\_\+\+\_\+t\+\_\+morph}]{\setlength{\rightskip}{0pt plus 5cm}void \+\_\+\+\_\+t\+\_\+morph (
\begin{DoxyParamCaption}
\item[{{\bf Tnode} $\ast$}]{t, }
\item[{Symbol}]{s, }
\item[{void $\ast$}]{surface, }
\item[{size\+\_\+t}]{size, }
\item[{int}]{allocate}
\end{DoxyParamCaption}
)}}\label{tree_8c_adbb495c31450fbe199aa913ecb77eed2}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000005}{Todo}]Handle the case where the surface of the node to be morphed is itself a tree \end{DoxyRefDesc}
\hypertarget{tree_8c_a302facc6d6e2d4937d560e081c828095}{\index{tree.\+c@{tree.\+c}!\+\_\+t\+\_\+detach\+\_\+by\+\_\+idx@{\+\_\+t\+\_\+detach\+\_\+by\+\_\+idx}}
\index{\+\_\+t\+\_\+detach\+\_\+by\+\_\+idx@{\+\_\+t\+\_\+detach\+\_\+by\+\_\+idx}!tree.\+c@{tree.\+c}}
\subsubsection[{\+\_\+t\+\_\+detach\+\_\+by\+\_\+idx}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tnode}$\ast$ \+\_\+t\+\_\+detach\+\_\+by\+\_\+idx (
\begin{DoxyParamCaption}
\item[{{\bf Tnode} $\ast$}]{t, }
\item[{int}]{i}
\end{DoxyParamCaption}
)}}\label{tree_8c_a302facc6d6e2d4937d560e081c828095}
Detatch the specified child from a node and return it

\begin{DoxyNote}{Note}
does not free the memory occupied by the child 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em t} & node to detach from \\
\hline
\mbox{\tt in}  & {\em i} & index of the child to detach \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the detatched child 
\end{DoxyReturn}
\hypertarget{tree_8c_ab28a85eae18cd8b29c15ab535e312902}{\index{tree.\+c@{tree.\+c}!\+\_\+t\+\_\+detach\+\_\+by\+\_\+ptr@{\+\_\+t\+\_\+detach\+\_\+by\+\_\+ptr}}
\index{\+\_\+t\+\_\+detach\+\_\+by\+\_\+ptr@{\+\_\+t\+\_\+detach\+\_\+by\+\_\+ptr}!tree.\+c@{tree.\+c}}
\subsubsection[{\+\_\+t\+\_\+detach\+\_\+by\+\_\+ptr}]{\setlength{\rightskip}{0pt plus 5cm}void \+\_\+t\+\_\+detach\+\_\+by\+\_\+ptr (
\begin{DoxyParamCaption}
\item[{{\bf Tnode} $\ast$}]{t, }
\item[{{\bf Tnode} $\ast$}]{c}
\end{DoxyParamCaption}
)}}\label{tree_8c_ab28a85eae18cd8b29c15ab535e312902}
search for a given node in the child list of a node and detatch it if found

\begin{DoxyNote}{Note}
does not free the memory occupied by c 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em t} & node to search \\
\hline
\mbox{\tt in}  & {\em c} & node to search for in child list \\
\hline
\end{DoxyParams}
\hypertarget{tree_8c_a91798c3f4945bb89b9c13e9b693ffd78}{\index{tree.\+c@{tree.\+c}!\+\_\+t\+\_\+morph@{\+\_\+t\+\_\+morph}}
\index{\+\_\+t\+\_\+morph@{\+\_\+t\+\_\+morph}!tree.\+c@{tree.\+c}}
\subsubsection[{\+\_\+t\+\_\+morph}]{\setlength{\rightskip}{0pt plus 5cm}void \+\_\+t\+\_\+morph (
\begin{DoxyParamCaption}
\item[{{\bf Tnode} $\ast$}]{dst, }
\item[{{\bf Tnode} $\ast$}]{src}
\end{DoxyParamCaption}
)}}\label{tree_8c_a91798c3f4945bb89b9c13e9b693ffd78}
Convert the surface of one node to that of another

Frees the original surface value if it was allocated.

\begin{DoxyNote}{Note}
only converts the type and surface, not the children! 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em dst} & Node to be morphed \\
\hline
\mbox{\tt in}  & {\em src} & Node type that dst should be morephed to \\
\hline
\end{DoxyParams}
\hypertarget{tree_8c_a571dd95ead249012211ffe5d180f56ec}{\index{tree.\+c@{tree.\+c}!\+\_\+t\+\_\+replace@{\+\_\+t\+\_\+replace}}
\index{\+\_\+t\+\_\+replace@{\+\_\+t\+\_\+replace}!tree.\+c@{tree.\+c}}
\subsubsection[{\+\_\+t\+\_\+replace}]{\setlength{\rightskip}{0pt plus 5cm}void \+\_\+t\+\_\+replace (
\begin{DoxyParamCaption}
\item[{{\bf Tnode} $\ast$}]{t, }
\item[{int}]{i, }
\item[{{\bf Tnode} $\ast$}]{r}
\end{DoxyParamCaption}
)}}\label{tree_8c_a571dd95ead249012211ffe5d180f56ec}
Replace the specified child with the given node.

\begin{DoxyNote}{Note}
frees the replaced child 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em t} & input node on which to operate \\
\hline
\mbox{\tt in}  & {\em i} & index to child be replaced \\
\hline
\mbox{\tt in}  & {\em r} & node to replace \\
\hline
\end{DoxyParams}
