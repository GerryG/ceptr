########################################################################################
# the base definitions for all systems.
# Copyright (C) 2013-2016, The MetaCurrency Project (Eric Harris-Braun, Arthur Brock, et. al).  This file is part of the Ceptr platform and is released under the terms of the license contained in the file LICENSE (GPLv3).

Context: SYS;

# These are "bottoming out" structures that are implemented by the system, not composed;
# thus we use the NULL_SYMBOL to indicate their surface definition, because it's not really defined in ceptr terms.
Structure: BIT,NULL_SYMBOL;             surface is 0 or 1
Structure: INTEGER,NULL_SYMBOL;         surface is a c int
Structure: FLOAT,NULL_SYMBOL;           surface is a c float
Structure: CHAR,NULL_SYMBOL;            surface is a c char
Structure: CSTRING,NULL_SYMBOL;         surface is a null terminated set of bytes
Structure: SYMBOL,NULL_SYMBOL;          surface is a c struct (SemID) representing symbols
Structure: STRUCTURE,NULL_SYMBOL;       surface is a c struct (SemID) representing structures
Structure: PROCESS,NULL_SYMBOL;         surface is a c struct (SemID) representing processes
Structure: PROTOCOL,NULL_SYMBOL;        surface is a c struct (SemID) representing protocols
Structure: RECEPTOR,NULL_SYMBOL;        surface is a c struct (SemID) representing receptors
Structure: SCAPE,NULL_SYMBOL;
Structure: ENUM,NULL_SYMBOL;            @todo
Structure: TREE_PATH,NULL_SYMBOL;       surface is an -1 terminated set of c ints
Structure: XADDR,NULL_SYMBOL;
Structure: SURFACE,NULL_SYMBOL;
Structure: TREE,NULL_SYMBOL;            surface is a c pointer to a tree
Structure: RECEPTOR_SURFACE,NULL_SYMBOL;   surface is a c pointer to a receptor structure
Structure: SEMTREX,NULL_SYMBOL;
Structure: STREAM,NULL_SYMBOL;          surface is a c struct holding state for unix (and other) streams
Structure: UUID,NULL_SYMBOL;            surface is a c struct holding a UUID
Structure: BLOB,NULL_SYMBOL;            surface is and undefined blob of bytes

# 
Declare: STRUCTURES,SYMBOLS,PROCESSES,PROTOCOLS,RECEPTORS,SCAPES;
Symbol: DEFINITIONS,[(STRUCTURES,SYMBOLS,PROCESSES,PROTOCOLS,RECEPTORS,*SCAPES)];

Declare: STRUCTURE_SYMBOL,STRUCTURE_SEQUENCE,STRUCTURE_OR,STRUCTURE_ZERO_OR_MORE,STRUCTURE_ONE_OR_MORE;
Symbol: SYMBOL_OF_STRUCTURE,STRUCTURE;
Symbol: STRUCTURE_ANYTHING,NULL_STRUCTURE;
Structure: STRUCTURE_DEF,|{STRUCTURE_SYMBOL|STRUCTURE_SEQUENCE|STRUCTURE_OR|STRUCTURE_ZERO_OR_MORE|STRUCTURE_ONE_OR_MORE|STRUCTURE_ZERO_OR_ONE|SYMBOL_OF_STRUCTURE|STRUCTURE_ANYTHING};
Symbol: STRUCTURE_LABEL,CSTRING;
Symbol: STRUCTURE_DEFINITION,[(STRUCTURE_LABEL,STRUCTURE_DEF)];
Symbol: STRUCTURES,[*STRUCTURE_DEFINITION];
Symbol: STRUCTURE_SEQUENCE,[+STRUCTURE_DEF];
Symbol: STRUCTURE_OR,[+STRUCTURE_DEF];
Symbol: STRUCTURE_SYMBOL,SYMBOL;
Symbol: STRUCTURE_ZERO_OR_MORE,STRUCTURE_DEF;
Symbol: STRUCTURE_ONE_OR_MORE,STRUCTURE_DEF;
Symbol: STRUCTURE_ZERO_OR_ONE,STRUCTURE_DEF;

Symbol: SYMBOL_STRUCTURE,STRUCTURE;
Symbol: SYMBOL_LABEL,CSTRING;
Symbol: SYMBOL_DEFINITION,[(SYMBOL_LABEL,SYMBOL_STRUCTURE)];
Symbol: SYMBOLS,[*SYMBOL_DEFINITION];

Symbol: BOOLEAN,BIT;
Symbol: SEMTREX_MATCH_PATH,TREE_PATH;       Path to symbol matched by semtrex
Declare: SEMTREX_SYMBOL_LITERAL,SEMTREX_SYMBOL_LITERAL_NOT,SEMTREX_SEQUENCE,SEMTREX_OR,SEMTREX_NOT,SEMTREX_SYMBOL_ANY,SEMTREX_ZERO_OR_MORE,SEMTREX_ONE_OR_MORE,SEMTREX_ZERO_OR_ONE,SEMTREX_VALUE_LITERAL,SEMTREX_VALUE_LITERAL_NOT,SEMTREX_GROUP,SEMTREX_WALK,SEMTREX_DESCEND;
Structure: SEMTREX_DEF,|{SEMTREX_SYMBOL_LITERAL|SEMTREX_SYMBOL_LITERAL_NOT|SEMTREX_SEQUENCE|SEMTREX_OR|SEMTREX_NOT|SEMTREX_SYMBOL_ANY|SEMTREX_ZERO_OR_MORE|SEMTREX_ONE_OR_MORE|SEMTREX_ZERO_OR_ONE|SEMTREX_VALUE_LITERAL|SEMTREX_VALUE_LITERAL_NOT|SEMTREX_GROUP|SEMTREX_WALK|SEMTREX_DESCEND};
Symbol: SEMTREX_SYMBOL,SYMBOL;              Symbols in the literal set
Symbol: SEMTREX_SYMBOL_SET,[+SEMTREX_SYMBOL];
Structure: SEMTREX_SYMBOL_LITERAL_DEF,(|{SEMTREX_SYMBOL|SEMTREX_SYMBOL_SET},*!);
Symbol: SEMTREX_SYMBOL_LITERAL,SEMTREX_SYMBOL_LITERAL_DEF;        matches on the semantic type.
Symbol: SEMTREX_SYMBOL_LITERAL_NOT,SEMTREX_SYMBOL_LITERAL_DEF;    matches any symbol or value of the node except.
Symbol: SEMTREX_SEQUENCE,[+SEMTREX_DEF];        Match on a sequence of child nodes which are any valid semtrex's.  Ex: comma separated nodes
#///@todo, the structure really should be something like SEMTREX_PAIR
Symbol: SEMTREX_OR,[(SEMTREX_DEF,SEMTREX_DEF)];     Logical OR between two Semtrex expressions.      Ex: |
Symbol: SEMTREX_NOT,SEMTREX_DEF;            Logical ~ between of a Semtrex expressions.      Ex: ~ (not implemented)
Symbol: SEMTREX_SYMBOL_ANY,[?!];            match any symbol or value of the node.           Ex: .
Symbol: SEMTREX_ZERO_OR_MORE,SEMTREX_DEF;   Requires one child Semtrex and matches on zero or more of that Semtrex.  Ex: /0/TestSemtrex*
Symbol: SEMTREX_ONE_OR_MORE,SEMTREX_DEF;    Requires one child Semtrex and matches on one or more of that Semtrex.   Ex: /0/TestSemtrex+
Symbol: SEMTREX_ZERO_OR_ONE,SEMTREX_DEF;    Requires one child Semtrex and matches on zero or one of that Semtrex.   Ex: /0/TestSemtrex?
Symbol: SEMTREX_VALUE_SET,[+!];             this is of the symbols to match on
Structure: SEMTREX_VALUE_LITERAL_DEF,|{!|SEMTREX_VALUE_SET};
Symbol: SEMTREX_VALUE_LITERAL,SEMTREX_VALUE_LITERAL_DEF;         Matches on the semantic type and the data values.
Symbol: SEMTREX_VALUE_LITERAL_NOT,SEMTREX_VALUE_LITERAL_DEF;      Matches on logical not of semantic type and data values
Symbol: SEMTREX_GROUP,SYMBOL;               Grouping, should have 1 child.. bad def!!       Ex: <...>operator
Symbol: SEMTREX_DESCEND,SEMTREX_DEF;     
Symbol: SEMTREX_WALK,SEMTREX_DEF;
Symbol: SEMTREX_MATCH,INTEGER;              @todo this is actually more like [(SEMTREX_MATCH_SYMBOL,SEMTREX_MATCH_PATH,SEMTREX_MATCH_SIBLINGS_COUNT, recurseon:SEMTREX_MATCH)] but we're using the surface of the root as well which is an INTEGER.
Symbol: SEMTREX_MATCH_CURSOR,NULL_STRUCTURE;   stores c pointer to tree node at start of match
Symbol: SEMTREX_MATCH_RESULTS,NULL_STRUCTURE;  In the FSA_ID, keeps track of which part matches so it can be referenced
Symbol: SEMTREX_MATCH_SYMBOL,SYMBOL;
Symbol: SEMTREX_MATCH_SIBLINGS_COUNT,INTEGER;  In the FSA_ID, it's the length of the match

Symbol: ASCII_CHAR,CHAR;
Symbol: ASCII_CHARS,[+ASCII_CHAR];

Symbol: RECEPTOR_XADDR,XADDR;               An Xaddr that points to a receptor
Declare: EXPECTATIONS,SIGNALS;
Structure: ASPECT,(EXPECTATIONS,SIGNALS);
Symbol: DEFAULT_ASPECT,ASPECT;              
Symbol: FLUX,[+%ASPECT];                    tree to hold all incoming and in process signals on the various aspects
Symbol: SCAPE_SPEC,NULL_STRUCTURE;          @todo...
Symbol: ASPECT_IDENT,SYMBOL;                when we get ranges, this should limit the surface symbol those of ASPECT structure
Symbol: ASPECT_TYPE,BIT;                    really should be an enum of IN, OUT
Symbol: ASPECT_LABEL,CSTRING;
Symbol: ASPECT_DEF,[(ASPECT_TYPE,ASPECT_LABEL)];   what else goes in the aspect definition?
Symbol: ASPECTS,[+ASPECT_DEF];
Symbol: CARRIER,SYMBOL;
Symbol: BODY,TREE;                          orthogonal tree that holds message body
Symbol: SIGNAL_UUID,UUID;
Symbol: IN_RESPONSE_TO_UUID,UUID;
Symbol: RECEPTOR_PATH,TREE_PATH;
Symbol: RECEPTOR_PATHS,[+RECEPTOR_PATH];
Symbol: RECEPTOR_ADDR,INTEGER;
Structure: RECEPTOR_ADDRESS,|{RECEPTOR_ADDR|RECEPTOR_PATH};
Symbol: FROM_ADDRESS,RECEPTOR_ADDRESS;
Symbol: TO_ADDRESS,RECEPTOR_ADDRESS;
Declare: END_CONDITIONS;
Symbol: ENVELOPE,[(FROM_ADDRESS,TO_ADDRESS,ASPECT_IDENT,CARRIER,SIGNAL_UUID,?|{END_CONDITIONS|IN_RESPONSE_TO_UUID})];
Symbol: SIGNAL,[(ENVELOPE,BODY)];                        a signal on the flux.  It's first child is the contents of the signal
Symbol: SIGNALS,[*SIGNAL];                  list of signals on an aspect in the flux
Symbol: PENDING_SIGNALS,[*SIGNAL];               list of signals pending to be sent by the SYS_RECEPTOR
Symbol: CODE_PATH,TREE_PATH;
Symbol: PROCESS_IDENT,INTEGER;
Symbol: WAKEUP_REFERENCE,[(PROCESS_IDENT,CODE_PATH)];
Symbol: PENDING_RESPONSE,[(SIGNAL_UUID,CARRIER,WAKEUP_REFERENCE,END_CONDITIONS)];
Symbol: PENDING_RESPONSES,[*PENDING_RESPONSE];
Symbol: RESPONSE_CARRIER,SYMBOL;            expected carrier for the response to a signal that "listen" to changes on the flux
Symbol: PATTERN,SEMTREX_DEF;                expectation is a semtrex (thus has one child which is the first part of the semtrex)
Symbol: ACTION,PROCESS;                     code tree_ID, which specifies the action to perform when an expectation's semtrex matches
Declare: PARAMS,SEMANTIC_MAP;
Symbol: EXPECTATION,[(CARRIER,PATTERN,ACTION,PARAMS,END_CONDITIONS,?SEMANTIC_MAP)];
Symbol: EXPECTATIONS,[*EXPECTATION];        list of carrier/expectation/action tress
Symbol: PROCESS_NAME,CSTRING;
Symbol: PROCESS_INTENTION,CSTRING;
Declare: PROCESS_SIGNATURE;
Symbol: CODE,[!];
Symbol: PROCESS_DEFINITION,[(PROCESS_NAME,PROCESS_INTENTION,CODE,PROCESS_SIGNATURE)];
Symbol: PROCESSES,[*PROCESS_DEFINITION];

Declare: GOAL,ROLE,USAGE,WEAL;
Structure: SEMANTIC_REFERENCE,|{GOAL|ROLE|USAGE|WEAL};
Symbol: SLOT_IS_VALUE_OF,SYMBOL;
Symbol: SLOT_CHILDREN,[!];
Structure: SLOT_STRUCTURE,(SEMANTIC_REFERENCE,?SLOT_IS_VALUE_OF,?SLOT_CHILDREN);  semantic id and optional indicator to fill the value not the structure for the element in the template that needs filling
Symbol: SLOT,SLOT_STRUCTURE;
Symbol: REPLACEMENT_VALUE,[!];        what to fill the slot with
Symbol: SEMANTIC_LINK,[(SEMANTIC_REFERENCE,REPLACEMENT_VALUE)];   mapping between a semantic reference and replacement value, used for filling templates
Symbol: SEMANTIC_MAP,[(+SEMANTIC_LINK)];


Symbol: SIGNATURE_LABEL,CSTRING;
Symbol: SIGNATURE_STRUCTURE,STRUCTURE;      the structure that would match
Symbol: SIGNATURE_SYMBOL,SYMBOL;            the symbol that would match
Symbol: SIGNATURE_PROCESS,SYMBOL;           the output signature of the process
Symbol: SIGNATURE_PASSTHRU,NULL_STRUCTURE;
Symbol: SIGNATURE_ANY,NULL_STRUCTURE;
Symbol: SIGNATURE_OPTIONAL,NULL_STRUCTURE;
Symbol: SIGNATURE_OUTPUT_TYPE,[|{SIGNATURE_STRUCTURE|SIGNATURE_SYMBOL|SIGNATURE_PROCESS|SIGNATURE_PASSTHRU}];           the semantic type expected as result i.e. either PROCESS/STRUCTURE/SYMBOL or PASSTHRU when the type comes from a reduction of a SIGNATURE_ANY
Structure: SIGNATURE_SEMANTIC_VARIANTS,|{SIGNATURE_STRUCTURE|SIGNATURE_SYMBOL|SIGNATURE_PROCESS|SIGNATURE_ANY};
Symbol: SIGNATURE_INPUT_TYPE,[(SIGNATURE_SEMANTIC_VARIANTS,?SIGNATURE_OPTIONAL)];    the semantic type that would expected as input i.e. either PROCESS/STRUCTURE/SYMBOL
Symbol: INPUT_SIGNATURE,[(SIGNATURE_LABEL,SIGNATURE_INPUT_TYPE)];
Symbol: OUTPUT_SIGNATURE,[(SIGNATURE_LABEL,SIGNATURE_OUTPUT_TYPE)];

Symbol: EXPECTED_SLOT,SLOT_STRUCTURE;  use of the slot structure not as a slot but as what kind of slot to expect (for the template signature)
Symbol: TEMPLATE_SIGNATURE,[(*EXPECTED_SLOT)];
Structure: PROCESS_FORM,(OUTPUT_SIGNATURE,*INPUT_SIGNATURE,*TEMPLATE_SIGNATURE);
Symbol: PROCESS_SIGNATURE,PROCESS_FORM;

Symbol: RUN_TREE,[(CODE,PARAMS,?CODE)];     think about this as a stack frame and its code and error handling code
Symbol: PARAM_REF,TREE_PATH;                used in a code tree as a reference to a parameter
Symbol: SIGNAL_REF,TREE_PATH;               used in a code tree triggered by an expectation as a reference to a part of the signal that triggered the action.
Symbol: PARAMS,[*!];
Symbol: RESULT_SYMBOL,SYMBOL;
Symbol: REDUCTION_ERROR_SYMBOL,SYMBOL;

Symbol: ROLE,SYMBOL;  A role stands for an expected agent, thus the symbol stored in a ROLE must be limited to those of structure RECEPTOR_ADDRESS.
Symbol: GOAL,SYMBOL; A goal stands for an intended process, thus the symbol stored in a GOAL must be limited to those that are uses of the PROCESS structure.
Symbol: USAGE,SYMBOL; A usage stands for a(n) X of a Symbol.
Symbol: WEAL,SYMBOL; A weal stands for a included protocol, the the symbol store in an WEAL must be limited to those that are uses of the PROTOCOL structure
Symbol: SOURCE,[+ROLE];
Symbol: DESTINATION,[+ROLE];
Symbol: EXPECT,[(ROLE,SOURCE,PATTERN,ACTION,?PARAMS)];
Symbol: INITIATE,[(ROLE,DESTINATION,ACTION)];
Symbol: PNAME,PROTOCOL;
Symbol: INCLUSION,[(PNAME,+|{RESOLUTION|CONNECTION})];
Structure: INTERACTION,(*EXPECT,*INITIATE);
Symbol: WHICH_INTERACTION,SYMBOL;   the symbols stored in an WHICH_INTERACTION must be limited to those that are uses of the INTERACTION structure

Symbol: PROTOCOLS,[*PROTOCOL_DEFINITION];
Symbol: ACTUAL_PROCESS,PROCESS;
Symbol: ACTUAL_RECEPTOR,RECEPTOR_ADDRESS;
Symbol: ACTUAL_SYMBOL,SYMBOL;
Symbol: ACTUAL_PROTOCOL,PROTOCOL;
Symbol: ACTUAL_VALUE,[!];  this really can't be anything, rather only something that's a SYMBOL semantic type
Symbol: WHICH_PROCESS,[(GOAL,ACTUAL_PROCESS)];
Symbol: WHICH_RECEPTOR,[(ROLE,ACTUAL_RECEPTOR)];
Symbol: WHICH_SYMBOL,[(USAGE,ACTUAL_SYMBOL)];
Symbol: WHICH_PROTOCOL,[(WEAL,ACTUAL_PROTOCOL)];
Symbol: WHICH_VALUE,[(ACTUAL_SYMBOL,ACTUAL_VALUE)];
Structure: MAPPING,|{WHICH_PROCESS|WHICH_RECEPTOR|WHICH_SYMBOL|WHICH_PROTOCOL|WHICH_VALUE};  maps abstract semantic reference to concrete instantiation
Symbol: RESOLUTION,MAPPING;
Symbol: WHICH_GOAL,[(GOAL,GOAL)];
Symbol: WHICH_ROLE,[(ROLE,ROLE)];
Symbol: WHICH_USAGE,[(USAGE,USAGE)];
Symbol: WHICH_WEAL,[(WEAL,WEAL)];
Structure: LINKING,|{WHICH_GOAL|WHICH_ROLE|WHICH_USAGE|WHICH_WEAL}; links two abstract semantic references (role/goal/usage/weal).
Symbol: CONNECTION,LINKING;
Symbol: PROTOCOL_BINDINGS,[+RESOLUTION];

Symbol: PROTOCOL_LABEL,CSTRING;
Symbol: PROTOCOL_SEMANTICS,[(*ROLE,*GOAL,*USAGE,*WEAL)];
Symbol: PROTOCOL_DEFINITION,[(PROTOCOL_LABEL,PROTOCOL_SEMANTICS,*%INTERACTION,*INCLUSION)];

Symbol: SCAPES,[*%SCAPE];
Symbol: MANIFEST_LABEL,CSTRING;           a label in the manifest to identify a binding
Symbol: MANIFEST_SPEC,SYMBOL;             a symbol to specify what type of data must be provided for a given manifest label
Symbol: MANIFEST_PAIR,[(MANIFEST_LABEL,MANIFEST_SPEC)];
Symbol: MANIFEST,[+MANIFEST_PAIR];         configuration template to be filled out for the installation of a receptor
Symbol: RECEPTOR_IDENTIFIER,INTEGER;      uuid that identifies receptors
Symbol: RECEPTOR_PACKAGE,[(MANIFEST,RECEPTOR_IDENTIFIER,DEFINITIONS)];
Symbol: BINDING_PAIR,[(MANIFEST_LABEL,!)];                a pair that matches a MANIFEST_LABEL with a given binding
Symbol: BINDINGS,[+BINDING_PAIR];                    specifics that match a MANIFEST and allow a receptor to be installed

Symbol: RECEPTOR_ELAPSED_TIME,INTEGER;
Symbol: RECEPTOR_LABEL,CSTRING;
Structure: RECEPTOR_IDENTITY,RECEPTOR_LABEL,RECEPTOR_IDENTIFIER; placeholder structure for compository identifier

Symbol: RECEPTOR_DEFINITION,[(RECEPTOR_LABEL,DEFINITIONS)];
Symbol: RECEPTORS,[*RECEPTOR_DEFINITION];

Symbol: RECEPTOR_STATE,[(FLUX,PENDING_SIGNALS,PENDING_RESPONSES,RECEPTOR_ELAPSED_TIME)];
Symbol: PARENT_CONTEXT_NUM,INTEGER;        identifies the semantic context of a receptors parent
Symbol: CONTEXT_NUM,INTEGER;               identifies the semantic context of a receptor
Symbol: INSTANCE_OF,RECEPTOR;              identifies the kind of receptor this is
Symbol: RECEPTOR_INSTANCE,[(INSTANCE_OF,CONTEXT_NUM,PARENT_CONTEXT_NUM,RECEPTOR_STATE)];

Symbol: SERIALIZED_RECEPTOR,BLOB;

Symbol: ACTIVE_RECEPTORS,[*RECEPTOR_XADDR];
Symbol: SYS_STATE,[(ACTIVE_RECEPTORS)];

Symbol: YEAR,INTEGER;
Symbol: MONTH,INTEGER;
Symbol: DAY,INTEGER;
Symbol: HOUR,INTEGER;
Symbol: MINUTE,INTEGER;
Symbol: SECOND,INTEGER;
Structure: DATE,YEAR,MONTH,DAY;
Structure: TIME,HOUR,MINUTE,SECOND;
Symbol: TODAY,DATE;
Symbol: NOW,TIME;
Structure: TIMESTAMP,TODAY,NOW;
Symbol: TICK,TIMESTAMP;

Symbol: ERROR_LOCATION,TREE_PATH;
Structure: REDUCTION_ERROR,ERROR_LOCATION;
Symbol: ZERO_DIVIDE_ERR,REDUCTION_ERROR;
Symbol: TOO_FEW_PARAMS_ERR,REDUCTION_ERROR;
Symbol: TOO_MANY_PARAMS_ERR,REDUCTION_ERROR;
Symbol: SIGNATURE_MISMATCH_ERR,REDUCTION_ERROR;
Symbol: NOT_A_PROCESS_ERR,REDUCTION_ERROR;
Symbol: NOT_IN_SIGNAL_CONTEXT_ERR,REDUCTION_ERROR;
Symbol: INCOMPATIBLE_TYPE_ERR,REDUCTION_ERROR;
Symbol: UNIX_ERRNO_ERR,REDUCTION_ERROR;
Symbol: DEAD_STREAM_READ_ERR,REDUCTION_ERROR;
Symbol: MISSING_SEMANTIC_MAP_ERR,REDUCTION_ERROR;
Symbol: MISMATCH_SEMANTIC_MAP_ERR,REDUCTION_ERROR;
Symbol: STRUCTURE_MISMATCH_ERR,REDUCTION_ERROR;

Symbol: GET_XADDR,XADDR;
Symbol: NEW_XADDR,XADDR;
Symbol: NEW_TYPE,SYMBOL;
Symbol: TIMEOUT_AT,TIMESTAMP;       specifies a timeout for requests
Symbol: COUNT,INTEGER;
Symbol: UNLIMITED,NULL_STRUCTURE;
Symbol: REPETITIONS,[|{COUNT|UNLIMITED}];
Symbol: END_CONDITIONS,[(?TIMEOUT_AT,?REPETITIONS)];

Symbol: ITERATE_ON_SYMBOL,SYMBOL;
Symbol: ITERATION_DATA,[!];    data to iterate over
Symbol: BLOCK,[!];    set of processes for DO

Process: NOOP,0,"no-op","result",SIGNATURE_PASSTHRU,NULL_STRUCTURE,"do",SIGNATURE_ANY,NULL_STRUCTURE,0;   this process reduces to its single "do" parameter.
Process: GET,0,"get instance value","value",SIGNATURE_ANY,NULL_STRUCTURE,"what",SIGNATURE_SYMBOL,GET_XADDR,0;   reduces to the value of the instance at the xaddr of the "what" parameter
Process: NEW,0,"new instance","xaddr",SIGNATURE_SYMBOL,NEW_XADDR,"what",SIGNATURE_SYMBOL,NEW_TYPE,0; reduces to the xaddr of a newly created instance of type NEW_TYPE.  the structures of "what" and "value" must match, but not the symbols
Process: DO,0,"do","result",SIGNATURE_PASSTHRU,NULL_STRUCTURE,"actions",SIGNATURE_SYMBOL,BLOCK,0; execute a BLOCK of instructions for side-effects returning the value of the last one.  We do the BLOCK thing because we don't yet have variable sized arugments for processes.  I would like it better if the actions could just be the children of the DO process
Process: IF,0,"if","result",SIGNATURE_PASSTHRU,NULL_STRUCTURE,"condition",SIGNATURE_PROCESS,BOOLEAN,"then",SIGNATURE_ANY,NULL_STRUCTURE,"else",SIGNATURE_OPTIONAL,SIGNATURE_ANY,NULL_STRUCTURE,0;  this is a traditional "if" process that reduces conditionally to either the "then" or the "else" parameter depending on the value of the "condition" parameter.  Note: we may be replacing this with a more lispy COND process
Process: ITERATE,0,"iterate a process","result",SIGNATURE_PASSTHRU,NULL_STRUCTURE,"condtion",SIGNATURE_PROCESS,BOOLEAN,"do",SIGNATURE_ANY,NULL_STRUCTURE,0;                     this process checks the structure of the result of the "condition" param, if it's a BOOLEAN, it treats the iteration as a while loop and iterates until the BOOLEAN is false; if it's an INTEGER it treats the iteration as repeat loop and iterates as many times as the value of the INTEGER; if it's a ITERATE_ON_SYMBOL then it iterates on all the instances of that symbol type which get added into the PARAMS each time through
Process: SAY,0,"send a message to a receptor","signal id",SIGNATURE_SYMBOL,SIGNAL_UUID,"to",SIGNATURE_SYMBOL,TO_ADDRESS,"on",SIGNATURE_SYMBOL,ASPECT_IDENT,"carrier",SIGNATURE_SYMBOL,CARRIER,"message",SIGNATURE_ANY,NULL_STRUCTURE,0;
Process: REQUEST,0,"send a request to a receptor","response",SIGNATURE_ANY,NULL_STRUCTURE,"of",SIGNATURE_SYMBOL,TO_ADDRESS,"on",SIGNATURE_SYMBOL,ASPECT_IDENT,"carrier",SIGNATURE_SYMBOL,CARRIER,"message",SIGNATURE_ANY,NULL_STRUCTURE,"expect response on",SIGNATURE_SYMBOL,RESPONSE_CARRIER,"until",SIGNATURE_OPTIONAL,SIGNATURE_SYMBOL,END_CONDITIONS,"callback",SIGNATURE_OPTIONAL,SIGNATURE_PROCESS,NULL_SYMBOL,0;  if there is no "callback" param, then this process will block until the result comes back or the "until" causes cleanup of pending request.

Process: LISTEN,0,"plant a listener","error",SIGNATURE_SYMBOL,REDUCTION_ERROR_SYMBOL,"on",SIGNATURE_SYMBOL,ASPECT_IDENT,"for",SIGNATURE_SYMBOL,CARRIER,"match",SIGNATURE_SYMBOL,PATTERN,"do",SIGNATURE_OPTIONAL,SIGNATURE_SYMBOL,ACTION,"with",SIGNATURE_OPTIONAL,SIGNATURE_SYMBOL,PARAMS,"until",SIGNATURE_OPTIONAL,SIGNATURE_SYMBOL,END_CONDITIONS,0;  If you don't provide an action, the assumption is that the LISTEN process will block and  will reduce to the SEMTREX_MATCH.  This will also force the END_CONDITIONS/REPETITIONS to COUNT:1.  If "for" carrier is NULL_SYMBOL the expectation will match on all carriers.

Process: RESPOND,0,"respond to signal","response id",SIGNATURE_SYMBOL,SIGNAL_UUID,"respond on",SIGNATURE_SYMBOL,CARRIER,"response contents",SIGNATURE_ANY,NULL_STRUCTURE,0;
Process: QUOTE,0,"quote a process so that it can be passed as a value","result",SIGNATURE_PASSTHRU,NULL_STRUCTURE,"process",SIGNATURE_PROCESS,NULL_PROCESS,0;
Process: FILL_FROM_MATCH,0,"fill template from match results","result",SIGNATURE_ANY,NULL_STRUCTURE,0;
Process: RAISE,0,"raise reduction error","result",SIGNATURE_STRUCTURE,NULL_STRUCTURE,"error",SIGNATURE_SYMBOL,REDUCTION_ERROR_SYMBOL,0;   this process doesn't really return anything, because it triggers the handler for the error in the "error" parameter
Process: STREAM_READ,0,"read from a stream","result",SIGNATURE_PASSTHRU,NULL_STRUCTURE,"stream",SIGNATURE_STRUCTURE,STREAM,"into",SIGNATURE_SYMBOL,RESULT_SYMBOL,0;  the data on the stream will appear as the surface of the symbol type given by the "into" param. Clearly this could get ugly as there is no semantic checking that that's ok...
Process: STREAM_WRITE,0,"write to a stream","result",SIGNATURE_PASSTHRU,NULL_STRUCTURE,"stream",SIGNATURE_STRUCTURE,STREAM,"what",SIGNATURE_ANY,NULL_STRUCTURE,0;
Process: STREAM_ALIVE,0,"test if stream is alive for reading","alive",SIGNATURE_SYMBOL,BOOLEAN,"stream",SIGNATURE_STRUCTURE,STREAM,0;
Process: CONCAT_STR,0,"concatinate strings","concatenation",SIGNATURE_STRUCTURE,CSTRING,"into",SIGNATURE_SYMBOL,RESULT_SYMBOL,"str1",SIGNATURE_STRUCTURE,CSTRING,"str2",SIGNATURE_STRUCTURE,CSTRING,0;  concatenates two strings of any symbol type into an new symbol type specified by the "into" parameter
Process: ADD_INT,0,"addition","sum",SIGNATURE_STRUCTURE,INTEGER,"augend",SIGNATURE_STRUCTURE,INTEGER,"addend",SIGNATURE_STRUCTURE,INTEGER,0;
Process: SUB_INT,0,"subtract","difference",SIGNATURE_STRUCTURE,INTEGER,"minuend",SIGNATURE_STRUCTURE,INTEGER,"subtrahend",SIGNATURE_STRUCTURE,INTEGER,0;
Process: MULT_INT,0,"multiply","product",SIGNATURE_STRUCTURE,INTEGER,"multiplicand",SIGNATURE_STRUCTURE,INTEGER,"multiplier",SIGNATURE_STRUCTURE,INTEGER,0;
Process: DIV_INT,0,"divide","quotient",SIGNATURE_STRUCTURE,INTEGER,"dividend",SIGNATURE_STRUCTURE,INTEGER,"divisor",SIGNATURE_STRUCTURE,INTEGER,0;
Process: MOD_INT,0,"modulo","remainder",SIGNATURE_STRUCTURE,INTEGER,"dividend",SIGNATURE_STRUCTURE,INTEGER,"divisor",SIGNATURE_STRUCTURE,INTEGER,0;
Process: EQ_INT,0,"test equality","equality",SIGNATURE_SYMBOL,BOOLEAN,"int1",SIGNATURE_STRUCTURE,INTEGER,"int2",SIGNATURE_STRUCTURE,INTEGER,0;
Process: LT_INT,0,"test less than","result",SIGNATURE_SYMBOL,BOOLEAN,"int1",SIGNATURE_STRUCTURE,INTEGER,"int2",SIGNATURE_STRUCTURE,INTEGER,0;
Process: GT_INT,0,"test greater than","result",SIGNATURE_SYMBOL,BOOLEAN,"int1",SIGNATURE_STRUCTURE,INTEGER,"int2",SIGNATURE_STRUCTURE,INTEGER,0;
Process: LTE_INT,0,"test less than or equal","result",SIGNATURE_SYMBOL,BOOLEAN,"int1",SIGNATURE_STRUCTURE,INTEGER,"int2",SIGNATURE_STRUCTURE,INTEGER,0;
Process: GTE_INT,0,"test greater than or equal","result",SIGNATURE_SYMBOL,BOOLEAN,"int1",SIGNATURE_STRUCTURE,INTEGER,"int2",SIGNATURE_STRUCTURE,INTEGER,0;
Process: INITIATE_PROTOCOL,0,"initiate the first step of a protocol","error",SIGNATURE_SYMBOL,REDUCTION_ERROR_SYMBOL,"protocol",SIGNATURE_SYMBOL,PNAME,"interaction",SIGNATURE_SYMBOL,WHICH_INTERACTION,"bindings",SIGNATURE_SYMBOL,PROTOCOL_BINDINGS,0;
Process: MAGIC,0,"dark magic","result",SIGNATURE_ANY,NULL_STRUCTURE,0;   this process reduces to hardcoded special things as a scaffold for things we don't know how to build in ceptr yet.

Symbol: STX_SL,NULL_STRUCTURE;
Symbol: STX_OP,NULL_STRUCTURE;
Symbol: STX_CP,NULL_STRUCTURE;
Symbol: STX_SET,NULL_STRUCTURE;
Symbol: STX_OS,NULL_STRUCTURE;
Symbol: STX_CS,NULL_STRUCTURE;
Symbol: STX_LABEL,CSTRING;
Symbol: STX_OG,CSTRING;
Symbol: STX_CG,NULL_STRUCTURE;
Symbol: STX_EQ,CSTRING;
Symbol: STX_NEQ,CSTRING;
Symbol: STX_WALK,NULL_STRUCTURE;
Symbol: STX_STAR,NULL_STRUCTURE;
Symbol: STX_PLUS,NULL_STRUCTURE;
Symbol: STX_Q,NULL_STRUCTURE;
Symbol: STX_OR,NULL_STRUCTURE;
Symbol: STX_COMMA,NULL_STRUCTURE;
Symbol: STX_EXCEPT,CSTRING;
Symbol: STX_NOT,NULL_STRUCTURE;
Symbol: STX_VAL_S,CSTRING;
Symbol: STX_VAL_C,CHAR;
Symbol: STX_VAL_I,INTEGER;
Symbol: STX_VAL_F,FLOAT;

Structure: STX_TOKEN_LIST,*|{STX_SL|STX_OP|STX_CP|STX_SET|STX_OS|STX_CS|STX_LABEL|STX_OG|STX_CG|STX_EQ|STX_NEQ|STX_WALK|STX_STAR|STX_PLUS|STX_Q|STX_OR|STX_COMMA|STX_EXCEPT|STX_NOT|STX_VAL_S|STX_VAL_C|STX_VAL_I|STX_VAL_F};
Symbol: STX_TOKENS,STX_TOKEN_LIST;

Symbol: STX_SIBS,[+!];
Symbol: STX_CHILD,[!];
Symbol: STX_POSTFIX,[!];

Symbol: TREE_DELTA_PATH,TREE_PATH;
Symbol: TREE_DELTA_VALUE,[!];
Symbol: TREE_DELTA_COUNT,INTEGER;
Structure: TREE_DELTA,TREE_DELTA_PATH,TREE_DELTA_VALUE,TREE_DELTA_COUNT;
Symbol: TREE_DELTA_ADD,TREE_DELTA;
Symbol: TREE_DELTA_REPLACE,TREE_DELTA;

Symbol: INSTANCES,[!];
Symbol: SYMBOL_INSTANCES,SYMBOL;

########################################################################################
# this context will contain SEED or POD structures that wrap receptors for global sharing
Context: COMPOSITORY;


########################################################################################
# definitions in progress that only exist on a local machine
Context: DEV_COMPOSITORY;

###### defs for an abstract requesting protocol
Symbol: REQUESTER,RECEPTOR_ADDRESS;
Symbol: RESPONDER,RECEPTOR_ADDRESS;
Symbol: REQUEST_DATA,SYMBOL;
Symbol: RESPONSE_DATA,SYMBOL;
Symbol: RESPONSE_HANDLER,PROCESS;
Symbol: REQUEST_HANDLER,PROCESS;

Symbol: backnforth,INTERACTION;
Data: req_code,(SLOT (GOAL:REQUEST_HANDLER) (SLOT_CHILDREN (REQUEST (SLOT (ROLE:RESPONDER) (SLOT_IS_VALUE_OF:TO_ADDRESS)) (ASPECT_IDENT:DEFAULT_ASPECT) (CARRIER:backnforth) (SLOT (USAGE:REQUEST_DATA)) (CARRIER:backnforth))));
Process: send_request,req_code,"send request","response",SIGNATURE_ANY,NULL_STRUCTURE,0;

Data: resp_code,(RESPOND (SIGNAL_REF:/1/4) (SLOT (GOAL:RESPONSE_HANDLER)));
Process: send_response,resp_code,"send response","response id",SIGNATURE_SYMBOL,SIGNAL_UUID,0;

Data: req_def,(PROTOCOL_DEFINITION
      (PROTOCOL_SEMANTICS
         (ROLE:REQUESTER)
         (ROLE:RESPONDER)
         (GOAL:REQUEST_HANDLER)
         (GOAL:RESPONSE_HANDLER)
         (USAGE:REQUEST_DATA)
         (USAGE:RESPONSE_DATA))
      (backnforth
         (INITIATE (ROLE:REQUESTER) (DESTINATION (ROLE:RESPONDER)) (ACTION:send_request))
         (EXPECT (ROLE:RESPONDER) (SOURCE (ROLE:REQUESTER)) (PATTERN (SEMTREX_SYMBOL_LITERAL (SLOT (USAGE:REQUEST_DATA) (SLOT_IS_VALUE_OF:SEMTREX_SYMBOL)))) (ACTION:send_response))));

Protocol: REQUESTING,req_def;

##### defs for recognize protocol (like ping, only semantic)
Symbol: RECOGNIZER,RECEPTOR_ADDRESS;
Symbol: RECOGNIZEE,RECEPTOR_ADDRESS;
Symbol: RECOGNITION,PROCESS;
Symbol: are_you,SEMTREX;
Symbol: i_am,RECEPTOR_IDENTITY;

Data: iam_code,(NOOP (i_am (RECEPTOR_LABEL:"super cept") (RECEPTOR_IDENTIFIER:314159)));
Process: fill_i_am,iam_code,"fill i am","identity",SIGNATURE_STRUCTURE,RECEPTOR_IDENTITY,"pattern",SIGNATURE_OPTIONAL,SIGNATURE_SYMBOL,are_you,0;

Data: recog_def,(PROTOCOL_DEFINITION
      (PROTOCOL_SEMANTICS)
      (INCLUSION (PNAME:REQUESTING)
                 (CONNECTION (WHICH_ROLE (ROLE:REQUESTER) (ROLE:RECOGNIZER)))
                 (CONNECTION (WHICH_ROLE (ROLE:RESPONDER) (ROLE:RECOGNIZEE)))
                 (CONNECTION (WHICH_GOAL (GOAL:REQUEST_HANDLER) (GOAL:RECOGNITION)))
                 (RESOLUTION (WHICH_SYMBOL (USAGE:REQUEST_DATA) (ACTUAL_SYMBOL:are_you)))
                 (RESOLUTION (WHICH_SYMBOL (USAGE:RESPONSE_DATA) (ACTUAL_SYMBOL:i_am)))
                 (RESOLUTION (WHICH_PROCESS (GOAL:RESPONSE_HANDLER) (ACTUAL_PROCESS:fill_i_am)))));

Protocol: RECOGNIZE,recog_def;

##### defs for shell receptor
Symbol: VERB,CSTRING;
Symbol: COMMAND_PARAMETER,CSTRING;
Structure: COMMAND,(VERB,*COMMAND_PARAMETER);
Symbol: SHELL_COMMAND,COMMAND;

###### definitions for an ALIVE protocol
Symbol: SERVER,RECEPTOR_ADDRESS;
Symbol: CLIENT,RECEPTOR_ADDRESS;
Symbol: PING,NULL_STRUCTURE;
Symbol: YUP,NULL_STRUCTURE;
Symbol: HANDLER,PROCESS;

Data: ping_resp,(RESPOND (SIGNAL_REF:/1/4) (YUP));
Process: respond_with_yup,ping_resp,"respond with yup","response id",SIGNATURE_SYMBOL,SIGNAL_UUID,0;
Symbol: alive,INTERACTION;

Data: alive_def,
      (PROTOCOL_DEFINITION
          (PROTOCOL_SEMANTICS (ROLE:SERVER) (ROLE:CLIENT) (GOAL:HANDLER))
          (alive
                (EXPECT (ROLE:SERVER) (SOURCE (ROLE:CLIENT)) (PATTERN (SEMTREX_SYMBOL_LITERAL (SEMTREX_SYMBOL:PING))) (ACTION:respond_with_yup))
                (EXPECT (ROLE:CLIENT) (SOURCE (ROLE:SERVER)) (PATTERN (SEMTREX_SYMBOL_LITERAL (SEMTREX_SYMBOL:YUP))) (SLOT (GOAL:HANDLER) (SLOT_IS_VALUE_OF:ACTION)))));

Protocol: ALIVE,alive_def;

##### defs for group receptor
Symbol: GROUP,RECEPTOR_ADDRESS;
Symbol: MEMBER,RECEPTOR_ADDRESS;
Symbol: enrollment,INTERACTION;
Symbol: converse,INTERACTION;
Symbol: MESSAGE,CSTRING;

Data: request_membership_code,(SAY (SLOT (ROLE:GROUP) (SLOT_IS_VALUE_OF:TO_ADDRESS)) (ASPECT_IDENT:DEFAULT_ASPECT) (CARRIER:enrollment) (YUP));   we could say anything, just using yup for now...
Process: request_membership,request_membership_code,"request membership","result",SIGNATURE_SYMBOL,SIGNAL_UUID,0;

Data: enroll_code,(NEW (NEW_TYPE:MEMBER) (SIGNAL_REF:/1/1));  /1/1 is the FROM_ADDRESS
Process: enroll,enroll_code,"enroll client","result",SIGNATURE_STRUCTURE,NULL_STRUCTURE,0;

Data: speak_code,(SAY (SLOT (ROLE:GROUP) (SLOT_IS_VALUE_OF:TO_ADDRESS)) (ASPECT_IDENT:DEFAULT_ASPECT) (CARRIER:converse) (SLOT (USAGE:MESSAGE)));
Process: speak,speak_code,"speak","result",SIGNATURE_SYMBOL,SIGNAL_UUID,0;

Data: group_listen_code,
      (DO (BLOCK
              (NEW (NEW_TYPE:MESSAGE) (PARAM_REF:/2/1))
              (ITERATE (PARAMS) (ITERATE_ON_SYMBOL:MEMBER) (SAY (PARAM_REF:/1/1/2/1/1/1) (ASPECT_IDENT:DEFAULT_ASPECT) (CARRIER:converse) (PARAM_REF:/2/1)))));  we could also use SIGNAL_REF /2/0 as the contents of the BODY
Process: group_listen,group_listen_code,"group_listen","result",SIGNATURE_SYMBOL,SIGNAL_UUID,0;

Data: group1_def,
      (PROTOCOL_DEFINITION
          (PROTOCOL_SEMANTICS (ROLE:GROUP) (ROLE:MEMBER) (GOAL:HANDLER))
          (enrollment
                (EXPECT (ROLE:GROUP) (ROLE:MEMBER) (PATTERN (SEMTREX_SYMBOL_ANY)) (ACTION:enroll))
                (INITIATE (ROLE:MEMBER) (ROLE:GROUP) (ACTION:request_membership)))
          (converse
                (EXPECT (ROLE:GROUP) (ROLE:MEMBER) (PATTERN (SEMTREX_SYMBOL_LITERAL (SEMTREX_SYMBOL:MESSAGE))) (ACTION:group_listen) (PARAMS (SLOT (USAGE:NULL_SYMBOL))))
                (EXPECT (ROLE:MEMBER) (ROLE:GROUP) (PATTERN (SEMTREX_SYMBOL_LITERAL (SEMTREX_SYMBOL:MESSAGE))) (SLOT (GOAL:HANDLER) (SLOT_IS_VALUE_OF:ACTION)))
                (INITIATE (ROLE:MEMBER) (ROLE:GROUP) (ACTION:speak)))
                );
                
Protocol: group1,group1_def;
 
########################################################################################
# a handful of definitions for testing things
Context: TEST;

Symbol: TEST_INT_SYMBOL,INTEGER;
Symbol: TEST_INT_SYMBOL2,INTEGER;
Symbol: TEST_FLOAT_SYMBOL,FLOAT;
Symbol: TEST_STR_SYMBOL,CSTRING;
Symbol: TEST_TREE_SYMBOL,TREE;      an orthogonal tree
Symbol: TEST_ANYTHING_SYMBOL,[!];   used to build trees in testing of unknown structure
Symbol: TEST_ANYTHING_SYMBOL2,[!];
Symbol: TEST_STREAM_SYMBOL,STREAM;
Symbol: TEST_NAME_SYMBOL,CSTRING;
Symbol: TEST_ALPHABETIZE_SCAPE_SYMBOL,SCAPE;
Symbol: TEST_SYMBOL_SYMBOL,SYMBOL;
Symbol: TESTING,SYMBOL;

########################################################################################
Context: CLOCK;

Symbol: TIME_TELLER,RECEPTOR_ADDRESS;
Symbol: TIME_HEARER,RECEPTOR_ADDRESS;
Symbol: CLOCK_TELL_TIME,NULL_STRUCTURE;
Symbol: tell_time,INTERACTION;
Data: time_req_code,(SLOT (GOAL:REQUEST_HANDLER) (SLOT_CHILDREN (REQUEST (SLOT (ROLE:TIME_TELLER) (SLOT_IS_VALUE_OF:TO_ADDRESS)) (ASPECT_IDENT:DEFAULT_ASPECT) (CARRIER:tell_time) (CLOCK_TELL_TIME) (RESPONSE_CARRIER:tell_time))));
Process: time_request,time_req_code,"request current time","response",SIGNATURE_SYMBOL,TICK,0;

# note: look for the clock protocol def in src/receptor.c#_r_defineClockReceptor
#       currently we don't have a way to define xaddrs as "immediate" data which
#       is necessary to complete the protocol definition for the clock receptor

########################################################################################
Context: STREAM_READER;

Symbol: LINE,CSTRING;                           text lines from unix streams

########################################################################################
Context: STREAM_WRITER;
