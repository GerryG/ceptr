########################################################################################
Context: SYS;

# These are "bottoming out" structures that are implemented by the system, not composed;
# thus we use the NULL_SYMBOL to indicate their surface definition, because it's not really defined in ceptr terms.
Structure: BIT,NULL_SYMBOL;             surface is 0 or 1
Structure: INTEGER,NULL_SYMBOL;         surface is a c int
Structure: FLOAT,NULL_SYMBOL;           surface is a c float
Structure: CHAR,NULL_SYMBOL;            surface is a c char
Structure: CSTRING,NULL_SYMBOL;         surface is a null terminated set of bytes
Structure: SYMBOL,NULL_SYMBOL;          surface is a c struct (SemID) representing symbols
Structure: ENUM,NULL_SYMBOL;            @todo
Structure: TREE_PATH,NULL_SYMBOL;       surface is an -1 terminated set of c ints
Structure: XADDR,NULL_SYMBOL;
Structure: SURFACE,NULL_SYMBOL;
Structure: TREE,NULL_SYMBOL;            surface is a c pointer to a tree
Structure: RECEPTOR,NULL_SYMBOL;        surface is a c pointer to a receptor structure
Structure: PROCESS,NULL_SYMBOL;         surface is a c struct (SemID) representing processes
Structure: STRUCTURE,NULL_SYMBOL;       surface is a c struct (SemID) representing structures
Structure: SCAPE,NULL_SYMBOL;
Structure: SEMTREX,NULL_SYMBOL;
Structure: STREAM,NULL_SYMBOL;          surface is a c struct holding state for unix (and other) streams
Structure: UUID,NULL_SYMBOL;            surface is a c struct holding a UUID
Structure: BLOB,NULL_SYMBOL;            surface is and undefined blob of bytes

# 
Declare: STRUCTURES,SYMBOLS,PROCESSES,PROTOCOLS,SCAPES,ASPECTS;
Symbol: DEFINITIONS,[*(STRUCTURES,SYMBOLS,PROCESSES,*PROTOCOLS,*SCAPES,*ASPECTS)];

Declare: STRUCTURE_SYMBOL,STRUCTURE_SEQUENCE,STRUCTURE_SYMBOL_SET,STRUCTURE_OR,STRUCTURE_ZERO_OR_MORE,STRUCTURE_ONE_OR_MORE;
Symbol: SYMBOL_OF_STRUCTURE,STRUCTURE;
Symbol: STRUCTURE_ANYTHING,NULL_STRUCTURE;
Structure: STRUCTURE_DEF,{STRUCTURE_SYMBOL,STRUCTURE_SEQUENCE,STRUCTURE_SYMBOL_SET,STRUCTURE_OR,STRUCTURE_ZERO_OR_MORE,STRUCTURE_ONE_OR_MORE,STRUCTURE_ZERO_OR_ONE,SYMBOL_OF_STRUCTURE,STRUCTURE_ANYTHING};
Symbol: STRUCTURE_LABEL,CSTRING;
Symbol: STRUCTURE_DEFINITION,[(STRUCTURE_LABEL,STRUCTURE_DEF)];
Symbol: STRUCTURES,[*STRUCTURE_DEFINITION];
Symbol: STRUCTURE_SEQUENCE,[+STRUCTURE_DEF];
Symbol: STRUCTURE_SYMBOL_SET,[+STRUCTURE_SYMBOL];
Symbol: STRUCTURE_SYMBOL,SYMBOL;
Symbol: STRUCTURE_OR,[(STRUCTURE_DEF,STRUCTURE_DEF)];
Symbol: STRUCTURE_ZERO_OR_MORE,STRUCTURE_DEF;
Symbol: STRUCTURE_ONE_OR_MORE,STRUCTURE_DEF;
Symbol: STRUCTURE_ZERO_OR_ONE,STRUCTURE_DEF;

Symbol: SYMBOL_STRUCTURE,STRUCTURE;
Symbol: SYMBOL_LABEL,CSTRING;
Symbol: SYMBOL_DECLARATION,[(SYMBOL_LABEL,SYMBOL_STRUCTURE)];
Symbol: SYMBOLS,[*SYMBOL_DECLARATION];

Symbol: BOOLEAN,BIT;
Symbol: SEMTREX_MATCH_PATH,TREE_PATH;       Path to symbol matched by semtrex
Declare: SEMTREX_SYMBOL_LITERAL,SEMTREX_SYMBOL_LITERAL_NOT,SEMTREX_SEQUENCE,SEMTREX_OR,SEMTREX_NOT,SEMTREX_SYMBOL_ANY,SEMTREX_ZERO_OR_MORE,SEMTREX_ONE_OR_MORE,SEMTREX_ZERO_OR_ONE,SEMTREX_VALUE_LITERAL,SEMTREX_VALUE_LITERAL_NOT,SEMTREX_GROUP,SEMTREX_WALK,SEMTREX_DESCEND;
Structure: SEMTREX_DEF,{SEMTREX_SYMBOL_LITERAL,SEMTREX_SYMBOL_LITERAL_NOT,SEMTREX_SEQUENCE,SEMTREX_OR,SEMTREX_NOT,SEMTREX_SYMBOL_ANY,SEMTREX_ZERO_OR_MORE,SEMTREX_ONE_OR_MORE,SEMTREX_ZERO_OR_ONE,SEMTREX_VALUE_LITERAL,SEMTREX_VALUE_LITERAL_NOT,SEMTREX_GROUP,SEMTREX_WALK,SEMTREX_DESCEND};
Symbol: SEMTREX_SYMBOL,SYMBOL;              Symbols in the literal set
Symbol: SEMTREX_SYMBOL_SET,[+SEMTREX_SYMBOL];
Structure: SEMTREX_SYMBOL_LITERAL_DEF,(|[SEMTREX_SYMBOL|SEMTREX_SYMBOL_SET],*!);
Symbol: SEMTREX_SYMBOL_LITERAL,SEMTREX_SYMBOL_LITERAL_DEF;        matches on the semantic type.
Symbol: SEMTREX_SYMBOL_LITERAL_NOT,SEMTREX_SYMBOL_LITERAL_DEF;    matches any symbol or value of the node except.
Symbol: SEMTREX_SEQUENCE,[+SEMTREX_DEF];        Match on a sequence of child nodes which are any valid semtrex's.  Ex: comma separated nodes
#///@todo, the structure really should be something like SEMTREX_PAIR
Symbol: SEMTREX_OR,[(SEMTREX_DEF,SEMTREX_DEF)];     Logical OR between two Semtrex expressions.      Ex: |
Symbol: SEMTREX_NOT,SEMTREX_DEF;            Logical ~ between of a Semtrex expressions.      Ex: ~ (not implemented)
Symbol: SEMTREX_SYMBOL_ANY,[?!];            match any symbol or value of the node.           Ex: .
Symbol: SEMTREX_ZERO_OR_MORE,SEMTREX_DEF;   Requires one child Semtrex and matches on zero or more of that Semtrex.  Ex: /0/TestSemtrex*
Symbol: SEMTREX_ONE_OR_MORE,SEMTREX_DEF;    Requires one child Semtrex and matches on one or more of that Semtrex.   Ex: /0/TestSemtrex+
Symbol: SEMTREX_ZERO_OR_ONE,SEMTREX_DEF;    Requires one child Semtrex and matches on zero or one of that Semtrex.   Ex: /0/TestSemtrex?
Symbol: SEMTREX_VALUE_SET,[+!];             this is of the symbols to match on
Structure: SEMTREX_VALUE_LITERAL_DEF,|[!|SEMTREX_VALUE_SET];
Symbol: SEMTREX_VALUE_LITERAL,SEMTREX_VALUE_LITERAL_DEF;         Matches on the semantic type and the data values.
Symbol: SEMTREX_VALUE_LITERAL_NOT,SEMTREX_VALUE_LITERAL_DEF;      Matches on logical not of semantic type and data values
Symbol: SEMTREX_GROUP,SYMBOL;               Grouping, should have 1 child.. bad def!!       Ex: <...>operator
Symbol: SEMTREX_DESCEND,SEMTREX_DEF;     
Symbol: SEMTREX_WALK,SEMTREX_DEF;
Symbol: SEMTREX_MATCH,INTEGER;              Returns result and sibling count.        Ex: {name:expr} (verify this is what it's supposed to do)
Symbol: SEMTREX_MATCH_CURSOR,NULL_STRUCTURE;   stores c pointer to tree node at start of match
Symbol: SEMTREX_MATCH_RESULTS,NULL_STRUCTURE;  In the FSA_ID, keeps track of which part matches so it can be referenced
Symbol: SEMTREX_MATCH_SYMBOL,SYMBOL;
Symbol: SEMTREX_MATCH_SIBLINGS_COUNT,INTEGER;  In the FSA_ID, it's the length of the match

Symbol: ASCII_CHAR,CHAR;
Symbol: ASCII_CHARS,[+ASCII_CHAR];

Symbol: RECEPTOR_XADDR,XADDR;               An Xaddr that points to a receptor
Declare: EXPECTATIONS,SIGNALS;
Structure: ASPECT,(EXPECTATIONS,SIGNALS);
Symbol: DEFAULT_ASPECT,ASPECT;              
Symbol: FLUX,[+%ASPECT];                    tree to hold all incoming and in process signals on the various aspects
Symbol: SCAPE_SPEC,NULL_STRUCTURE;          @todo...
Symbol: ASPECT_IDENT,SYMBOL;                when we get ranges, this should limit the surface symbol those of ASPECT structure
Symbol: ASPECT_TYPE,BIT;                    really should be an enum of IN, OUT
Symbol: ASPECT_LABEL,CSTRING;
Symbol: ASPECT_DEF,[(ASPECT_TYPE,ASPECT_LABEL)];   what else goes in the aspect definition?
Symbol: ASPECTS,[+ASPECT_DEF];
Symbol: CARRIER,SYMBOL;
Symbol: BODY,TREE;                          orthogonal tree that holds message body
Symbol: SIGNAL_UUID,UUID;
Symbol: IN_RESPONSE_TO_UUID,UUID;
Symbol: INSTANCE_NUM,INTEGER;               this a placeholder for better addressing later...
Symbol: RECEPTOR_PATH,TREE_PATH;
Structure: RECEPTOR_ADDRESS,|[INSTANCE_NUM|RECEPTOR_PATH];
Symbol: FROM_ADDRESS,RECEPTOR_ADDRESS;
Symbol: TO_ADDRESS,RECEPTOR_ADDRESS;
Declare: END_CONDITIONS;
Symbol: ENVELOPE,[(FROM_ADDRESS,TO_ADDRESS,ASPECT_IDENT,CARRIER,SIGNAL_UUID,?|[END_CONDITIONS|IN_RESPONSE_TO_UUID])];
Symbol: SIGNAL,[(ENVELOPE,BODY)];                        a signal on the flux.  It's first child is the contents of the signal
Symbol: SIGNALS,[*SIGNAL];                  list of signals on an aspect in the flux
Symbol: PENDING_SIGNALS,[*SIGNAL];               list of signals pending to be sent by the VM_HOST
Symbol: CODE_PATH,TREE_PATH;
Symbol: PROCESS_IDENT,INTEGER;
Symbol: WAKEUP_REFERENCE,[(PROCESS_IDENT,CODE_PATH)];
Symbol: PENDING_RESPONSE,[(SIGNAL_UUID,CARRIER,WAKEUP_REFERENCE,END_CONDITIONS)];
Symbol: PENDING_RESPONSES,[*PENDING_RESPONSE];
Symbol: RESPONSE_CARRIER,SYMBOL;            expected carrier for the response to a signal that "listen" to changes on the flux
Symbol: PATTERN,SEMTREX_DEF;                expectation is a semtrex (thus has one child which is the first part of the semtrex)
Symbol: ACTION,PROCESS;                     code tree_ID, which specifies the action to perform when an expectation's semtrex matches
Declare: PARAMS;
Symbol: EXPECTATION,[(CARRIER,PATTERN,ACTION,PARAMS,END_CONDITIONS)];
Symbol: EXPECTATIONS,[*EXPECTATION];                     list of carrier/expectation/action tress
Symbol: INTERPOLATE_SYMBOL,SYMBOL;          a place holder to indicate which symbol to insert into this part of the tree
Symbol: PROCESS_NAME,CSTRING;
Symbol: PROCESS_INTENTION,CSTRING;
Declare: PROCESS_SIGNATURE;
Symbol: PROCESS_CODING,[(PROCESS_NAME,PROCESS_INTENTION,PROCESS,PROCESS_SIGNATURE)];
Symbol: PROCESSES,[*PROCESS_CODING];

Symbol: SIGNATURE_LABEL,CSTRING;
Symbol: SIGNATURE_STRUCTURE,STRUCTURE;      the structure that would match
Symbol: SIGNATURE_SYMBOL,SYMBOL;            the symbol that would match
Symbol: SIGNATURE_PROCESS,SYMBOL;           the output signature of the process
Symbol: SIGNATURE_PASSTHRU,NULL_STRUCTURE;
Symbol: SIGNATURE_ANY,NULL_STRUCTURE;
Symbol: SIGNATURE_OPTIONAL,NULL_STRUCTURE;
Symbol: SIGNATURE_OUTPUT_TYPE,[{SIGNATURE_STRUCTURE,SIGNATURE_SYMBOL,SIGNATURE_PROCESS,SIGNATURE_PASSTHRU}];           the semantic type expected as result i.e. either PROCESS/STRUCTURE/SYMBOL or PASSTHRU when the type comes from a reduction of a SIGNATURE_ANY
Structure: SIGNATURE_SEMANTIC_VARIANTS,{SIGNATURE_STRUCTURE,SIGNATURE_SYMBOL,SIGNATURE_PROCESS,SIGNATURE_ANY};
Symbol: SIGNATURE_INPUT_TYPE,[(SIGNATURE_SEMANTIC_VARIANTS,?SIGNATURE_OPTIONAL)];    the semantic type that would expected as input i.e. either PROCESS/STRUCTURE/SYMBOL
Symbol: INPUT_SIGNATURE,[(SIGNATURE_LABEL,SIGNATURE_INPUT_TYPE)];
Symbol: OUTPUT_SIGNATURE,[(SIGNATURE_LABEL,SIGNATURE_OUTPUT_TYPE)];
Symbol: PROCESS_SIGNATURE,[(OUTPUT_SIGNATURE,*INPUT_SIGNATURE)];

Symbol: RUN_TREE,[!];                       think about this as a stack frame and its code
Symbol: PARAM_REF,TREE_PATH;                used in a code tree as a reference to a parameter
Symbol: SIGNAL_REF,TREE_PATH;               used in a code tree triggered by an expectation as a reference to a part of the signal that triggered the action.
Symbol: PARAMS,[*!];
Symbol: RESULT_SYMBOL,SYMBOL;
Symbol: REDUCTION_ERROR_SYMBOL,SYMBOL;

Symbol: ROLE,SYMBOL;  the symbol stored in a ROLE must be limmited to those of structure RECEPTOR_ADDRESS. we don't mean %RECEPTOR_ADDRESS as the structure because that actually means a symbol of of type receptor address.  Here we mean that the surface contains a symbol that itself must be of type RECEPTOR_ADDRESS, this is agian like a range specifier on the value of the surface.
Symbol: ANYBODY,NULL_STRUCTURE;
Symbol: SOURCE,[(*ROLE,?ANYBODY)];  hmm gotta be a way of specifying that this can't be empty (@todo)
Symbol: ROLE_PROCESS,[(ROLE,SOURCE,EXPECTATION)];
Symbol: CONVERSATION_LABEL,CSTRING;
Symbol: CONVERSATION,[(CONVERSATION_LABEL,+ROLE_PROCESS)];
Structure: PROTOCOL_DEF,(+ROLE,+CONVERSATION);
Symbol: PROTOCOLS,[+%PROTOCOL_DEF];

Symbol: SCAPES,[*%SCAPE];
Symbol: MANIFEST_LABEL,CSTRING;           a label in the manifest to identify a binding
Symbol: MANIFEST_SPEC,SYMBOL;             a symbol to specify what type of data must be provided for a given manifest label
Symbol: MANIFEST_PAIR,[(MANIFEST_LABEL,MANIFEST_SPEC)];
Symbol: MANIFEST,[+MANIFEST_PAIR];         configuration template to be filled out for the installation of a receptor
Symbol: RECEPTOR_IDENTIFIER,INTEGER;      uuid that identifies receptors
Symbol: RECEPTOR_PACKAGE,[(MANIFEST,RECEPTOR_IDENTIFIER,DEFINITIONS)];
Symbol: INSTALLED_RECEPTOR,TREE;          contains the installed receptor as well as state information (enabled,disabled_ID, etc..)
Symbol: BINDING_PAIR,[(MANIFEST_LABEL,!)];                a pair that matches a MANIFEST_LABEL with a given binding
Symbol: BINDINGS,[+BINDING_PAIR];                    specifics that match a MANIFEST and allow a receptor to be installed

Symbol: RECEPTOR_ELAPSED_TIME,INTEGER;
Symbol: RECEPTOR_STATE,[(?RECEPTOR_ELAPSED_TIME)];

Structure: RECEPTOR_DEF,DEFINITIONS,FLUX,RECEPTOR_STATE,PENDING_SIGNALS,PENDING_RESPONSES;

Symbol: SERIALIZED_RECEPTOR,BLOB;

Symbol: VM_HOST_RECEPTOR,RECEPTOR;
Symbol: ACTIVE_RECEPTORS,[*RECEPTOR_XADDR];
Symbol: VM_HOST_STATE,[(ACTIVE_RECEPTORS)];
Symbol: CLOCK_RECEPTOR,RECEPTOR;
Symbol: COMPOSITORY,RECEPTOR;         receptor that holds available receptor packages for installation

Symbol: YEAR,INTEGER;
Symbol: MONTH,INTEGER;
Symbol: DAY,INTEGER;
Symbol: HOUR,INTEGER;
Symbol: MINUTE,INTEGER;
Symbol: SECOND,INTEGER;
Structure: DATE,YEAR,MONTH,DAY;
Structure: TIME,HOUR,MINUTE,SECOND;
Symbol: TODAY,DATE;
Symbol: NOW,TIME;
Structure: TIMESTAMP,TODAY,NOW;
Symbol: TICK,TIMESTAMP;
Symbol: CLOCK_TELL_TIME,NULL_STRUCTURE;

Symbol: ERROR_LOCATION,TREE_PATH;
Structure: REDUCTION_ERROR,ERROR_LOCATION;
Symbol: ZERO_DIVIDE_ERR,REDUCTION_ERROR;
Symbol: TOO_FEW_PARAMS_ERR,REDUCTION_ERROR;
Symbol: TOO_MANY_PARAMS_ERR,REDUCTION_ERROR;
Symbol: SIGNATURE_MISMATCH_ERR,REDUCTION_ERROR;
Symbol: NOT_A_PROCESS_ERR,REDUCTION_ERROR;
Symbol: NOT_IN_SIGNAL_CONTEXT_ERR,REDUCTION_ERROR;
Symbol: INCOMPATIBLE_TYPE_ERR,REDUCTION_ERROR;
Symbol: UNIX_ERRNO_ERR,REDUCTION_ERROR;
Symbol: DEAD_STREAM_READ_ERR,REDUCTION_ERROR;

Symbol: GET_XADDR,XADDR;
Symbol: TIMEOUT_AT,TIMESTAMP;       specifies a timeout for requests
Symbol: COUNT,INTEGER;
Symbol: UNLIMITED,NULL_STRUCTURE;
Symbol: REPETITIONS,[|[COUNT|UNLIMITED]];
Symbol: END_CONDITIONS,[(?TIMEOUT_AT,?REPETITIONS)];

Process: NOOP,"no-op","result",SIGNATURE_PASSTHRU,NULL_STRUCTURE,"do",SIGNATURE_ANY,NULL_STRUCTURE,0;   this process reduces to its single "do" parameter.
Process: GET,"get instance value","value",SIGNATURE_ANY,NULL_STRUCTURE,"what",SIGNATURE_SYMBOL,GET_XADDR,0;   reduces to the value of the instance at the xaddr of the "what" parameter
Process: IF,"if","result",SIGNATURE_PASSTHRU,NULL_STRUCTURE,"condition",SIGNATURE_PROCESS,BOOLEAN,"then",SIGNATURE_ANY,NULL_STRUCTURE,"else",SIGNATURE_OPTIONAL,SIGNATURE_ANY,NULL_STRUCTURE,0;  this is a traditional "if" process that reduces conditionally to either the "then" or the "else" parameter depending on the value of the "condition" parameter.  Note: we may be replacing this with a more lispy COND process
Process: ITERATE,"iterate a process","result",SIGNATURE_PASSTHRU,NULL_STRUCTURE,"condtion",SIGNATURE_PROCESS,BOOLEAN,"do",SIGNATURE_ANY,NULL_STRUCTURE,0;                     this process checks the structure of the result of the "condition" param, if it's a BOOLEAN, it treats the iteration as a while loop and iterates until the BOOLEAN is false; if it's an INTEGER it treats the iteration as repeat loop and iterates as many times as the value of the INTEGER
Process: SAY,"send a message to a receptor","signal id",SIGNATURE_SYMBOL,SIGNAL_UUID,"to",SIGNATURE_SYMBOL,RECEPTOR_ADDRESS,"on",SIGNATURE_SYMBOL,ASPECT_IDENT,"carrier",SIGNATURE_SYMBOL,CARRIER,"message",SIGNATURE_ANY,NULL_STRUCTURE,0;
Process: REQUEST,"send a request to a receptor","response",SIGNATURE_ANY,NULL_STRUCTURE,"of",SIGNATURE_SYMBOL,RECEPTOR_ADDRESS,"on",SIGNATURE_SYMBOL,ASPECT_IDENT,"carrier",SIGNATURE_SYMBOL,CARRIER,"message",SIGNATURE_ANY,NULL_STRUCTURE,"respond on",SIGNATURE_SYMBOL,RESPONSE_CARRIER,"until",SIGNATURE_OPTIONAL,SIGNATURE_SYMBOL,END_CONDITIONS,"callback",SIGNATURE_OPTIONAL,SIGNATURE_PROCESS,NULL_SYMBOL,0;  if there is no "callback" param, then this process will block until the result comes back or the "until" causes cleanup of pending request.

Process: LISTEN,"plant a listener","error",SIGNATURE_SYMBOL,REDUCTION_ERROR_SYMBOL,"on",SIGNATURE_SYMBOL,ASPECT_IDENT,"for",SIGNATURE_SYMBOL,CARRIER,"match",SIGNATURE_SYMBOL,PATTERN,"do",SIGNATURE_OPTIONAL,SIGNATURE_SYMBOL,ACTION,"with",SIGNATURE_OPTIONAL,SIGNATURE_SYMBOL,PARAMS,"until",SIGNATURE_OPTIONAL,SIGNATURE_SYMBOL,END_CONDITIONS,0;  If you don't provide an action, the assumption is that the LISTEN process will block and  will reduce to the SEMTREX_MATCH.  This will also force the END_CONDITIONS/REPETITIONS to COUNT:1.  If "for" carrier is NULL_SYMBOL the expectation will match on all carriers.

Process: RESPOND,"respond to signal","response id",SIGNATURE_SYMBOL,SIGNAL_UUID,"respond on",SIGNATURE_SYMBOL,RESPONSE_CARRIER,"response contents",SIGNATURE_ANY,NULL_STRUCTURE,0;
Process: QUOTE,"quote a process so that it can be passed as a value","result",SIGNATURE_PASSTHRU,NULL_STRUCTURE,"process",SIGNATURE_PROCESS,NULL_PROCESS,0;
Process: INTERPOLATE_FROM_MATCH,"interploate match result in place","result",SIGNATURE_STRUCTURE,TREE,0;
Process: RAISE,"raise reduction error","result",SIGNATURE_STRUCTURE,NULL_STRUCTURE,"error",SIGNATURE_SYMBOL,REDUCTION_ERROR_SYMBOL,0;   this process doesn't really return anything, because it triggers the handler for the error in the "error" parameter
Process: STREAM_READ,"read from a stream","result",SIGNATURE_PASSTHRU,NULL_STRUCTURE,"stream",SIGNATURE_STRUCTURE,STREAM,"into",SIGNATURE_SYMBOL,RESULT_SYMBOL,0;  the data on the stream will appear as the surface of the symbol type given by the "into" param. Clearly this could get ugly as there is no semantic checking that that's ok...
Process: STREAM_WRITE,"write to a stream","result",SIGNATURE_PASSTHRU,NULL_STRUCTURE,"stream",SIGNATURE_STRUCTURE,STREAM,"what",SIGNATURE_ANY,NULL_STRUCTURE,0;
Process: STREAM_ALIVE,"test if stream is alive for reading","alive",SIGNATURE_SYMBOL,BOOLEAN,"stream",SIGNATURE_STRUCTURE,STREAM,0;
Process: CONCAT_STR,"concatinate strings","concatenation",SIGNATURE_STRUCTURE,CSTRING,"into",SIGNATURE_SYMBOL,RESULT_SYMBOL,"str1",SIGNATURE_STRUCTURE,CSTRING,"str2",SIGNATURE_STRUCTURE,CSTRING,0;  concatenates two strings of any symbol type into an new symbol type specified by the "into" parameter
Process: ADD_INT,"addition","sum",SIGNATURE_STRUCTURE,INTEGER,"augend",SIGNATURE_STRUCTURE,INTEGER,"addend",SIGNATURE_STRUCTURE,INTEGER,0;
Process: SUB_INT,"subtract","difference",SIGNATURE_STRUCTURE,INTEGER,"minuend",SIGNATURE_STRUCTURE,INTEGER,"subtrahend",SIGNATURE_STRUCTURE,INTEGER,0;
Process: MULT_INT,"multiply","product",SIGNATURE_STRUCTURE,INTEGER,"multiplicand",SIGNATURE_STRUCTURE,INTEGER,"multiplier",SIGNATURE_STRUCTURE,INTEGER,0;
Process: DIV_INT,"divide","quotient",SIGNATURE_STRUCTURE,INTEGER,"dividend",SIGNATURE_STRUCTURE,INTEGER,"divisor",SIGNATURE_STRUCTURE,INTEGER,0;
Process: MOD_INT,"modulo","remainder",SIGNATURE_STRUCTURE,INTEGER,"dividend",SIGNATURE_STRUCTURE,INTEGER,"divisor",SIGNATURE_STRUCTURE,INTEGER,0;
Process: EQ_INT,"test equality","equality",SIGNATURE_SYMBOL,BOOLEAN,"int1",SIGNATURE_STRUCTURE,INTEGER,"int2",SIGNATURE_STRUCTURE,INTEGER,0;
Process: LT_INT,"test less than","result",SIGNATURE_SYMBOL,BOOLEAN,"int1",SIGNATURE_STRUCTURE,INTEGER,"int2",SIGNATURE_STRUCTURE,INTEGER,0;
Process: GT_INT,"test greater than","result",SIGNATURE_SYMBOL,BOOLEAN,"int1",SIGNATURE_STRUCTURE,INTEGER,"int2",SIGNATURE_STRUCTURE,INTEGER,0;
Process: LTE_INT,"test less than or equal","result",SIGNATURE_SYMBOL,BOOLEAN,"int1",SIGNATURE_STRUCTURE,INTEGER,"int2",SIGNATURE_STRUCTURE,INTEGER,0;
Process: GTE_INT,"test greater than or equal","result",SIGNATURE_SYMBOL,BOOLEAN,"int1",SIGNATURE_STRUCTURE,INTEGER,"int2",SIGNATURE_STRUCTURE,INTEGER,0;

Process: MAGIC,"dark magic","result",SIGNATURE_ANY,NULL_STRUCTURE,0;   this process reduces to hardcoded special things as a scaffold for things we don't know how to build in ceptr yet.

Symbol: STX_SL,NULL_STRUCTURE;
Symbol: STX_OP,NULL_STRUCTURE;
Symbol: STX_CP,NULL_STRUCTURE;
Symbol: STX_SET,NULL_STRUCTURE;
Symbol: STX_OS,NULL_STRUCTURE;
Symbol: STX_CS,NULL_STRUCTURE;
Symbol: STX_LABEL,CSTRING;
Symbol: STX_OG,CSTRING;
Symbol: STX_CG,NULL_STRUCTURE;
Symbol: STX_EQ,CSTRING;
Symbol: STX_NEQ,CSTRING;
Symbol: STX_WALK,NULL_STRUCTURE;
Symbol: STX_STAR,NULL_STRUCTURE;
Symbol: STX_PLUS,NULL_STRUCTURE;
Symbol: STX_Q,NULL_STRUCTURE;
Symbol: STX_OR,NULL_STRUCTURE;
Symbol: STX_COMMA,NULL_STRUCTURE;
Symbol: STX_EXCEPT,CSTRING;
Symbol: STX_NOT,NULL_STRUCTURE;
Symbol: STX_VAL_S,CSTRING;
Symbol: STX_VAL_C,CHAR;
Symbol: STX_VAL_I,INTEGER;
Symbol: STX_VAL_F,FLOAT;

Structure: STX_TOKEN_LIST,*{STX_SL,STX_OP,STX_CP,STX_SET,STX_OS,STX_CS,STX_LABEL,STX_OG,STX_CG,STX_EQ,STX_NEQ,STX_WALK,STX_STAR,STX_PLUS,STX_Q,STX_OR,STX_COMMA,STX_EXCEPT,STX_NOT,STX_VAL_S,STX_VAL_C,STX_VAL_I,STX_VAL_F};
Symbol: STX_TOKENS,STX_TOKEN_LIST;

Symbol: STX_SIBS,[+!];
Symbol: STX_CHILD,[!];
Symbol: STX_POSTFIX,[!];

Symbol: TREE_DELTA_PATH,TREE_PATH;
Symbol: TREE_DELTA_VALUE,[!];
Symbol: TREE_DELTA_COUNT,INTEGER;
Structure: TREE_DELTA,TREE_DELTA_PATH,TREE_DELTA_VALUE,TREE_DELTA_COUNT;
Symbol: TREE_DELTA_ADD,TREE_DELTA;
Symbol: TREE_DELTA_REPLACE,TREE_DELTA;


########################################################################################
Context: LOCAL;

Symbol: LINE,CSTRING;                           text lines from unix streams

#defs for shell receptor
Symbol: VERB,CSTRING;
Symbol: COMMAND_PARAMETER,CSTRING;
Structure: COMMAND,(VERB,*COMMAND_PARAMETER);
Symbol: SHELL_COMMAND,COMMAND;

########################################################################################
Context: TEST;

Symbol: TEST_INT_SYMBOL,INTEGER;
Symbol: TEST_INT_SYMBOL2,INTEGER;
Symbol: TEST_FLOAT_SYMBOL,FLOAT;
Symbol: TEST_STR_SYMBOL,CSTRING;
Symbol: TEST_TREE_SYMBOL,TREE;
Symbol: TEST_TREE_SYMBOL2,TREE;
Symbol: TEST_STREAM_SYMBOL,STREAM;
Symbol: TEST_NAME_SYMBOL,CSTRING;
Symbol: TEST_RECEPTOR_SYMBOL,RECEPTOR;
Symbol: TEST_ALPHABETIZE_SCAPE_SYMBOL,SCAPE;
Symbol: TEST_SYMBOL_SYMBOL,SYMBOL;
Symbol: TESTING,SYMBOL;