#!/usr/local/bin/perl

# This file generates c code that defines system semantic definitions.
# it reads the file "base_defs" as a source file for creating the definition
#
# Copyright (C) 2013-2015, The MetaCurrency Project (Eric Harris-Braun, Arthur Brock, et. al).  This file is part of the Ceptr platform and is released under the terms of the license contained in the file LICENSE (GPLv3).

use strict;
use warnings;
use Data::Dumper;

my $defs_file = 'base_defs';
open(my $fh,'<:encoding(UTF-8)', $defs_file)
        or die "Could not open definitions source file '$defs_file' $!";
my $defs_c_file = 'base_defs.c';
open(my $cfh,'>:encoding(UTF-8)', $defs_c_file)
        or die "Could not open definitions c file '$defs_c_file' $!";
my $defs_h_file = 'base_defs.h';
open(my $hfh,'>:encoding(UTF-8)', $defs_h_file)
        or die "Could not open definitions c file '$defs_h_file' $!";

my %d;
my @d;
my %fmap = ('Structure'=>'sT','Symbol'=>'sY','Process'=>'sP');

while (my $def = <$fh>) {
    chomp $def;
    next if ($def =~ /^ *#/);       # ignore comments
    next if ($def) =~ /^[ \t]*$/;   #ignore whitespace lines
    if ($def =~ /(.*): *(.*);(.*)/) {
        my $type = $1;
        my @params = split /,/,$2;
        #        my $name = shift @params;
        push @d,[$type,@params];
        my $comment = $3;
        my $h;
        if (! exists $d{$type}) {$d{$type} = []};

        my $a = $d{$type};
        push @$a, [@params];
    } else {
        die "unable to parse $def";
    }
}
#print Dumper(\@d);
#print $fmap{'Symbol'};

print $cfh <<'EOF';
/**
 * @ingroup def
 *
 * @file base_defs.c
 * @brief auto-generated system definitions
 *
 * NOTE: this file is auto-generated by base_defs.pl
 *
 * @copyright Copyright (C) 2013-2015, The MetaCurrency Project (Eric Harris-Braun, Arthur Brock, et. al).  This file is part of the Ceptr platform and is released under the terms of the license contained in the file LICENSE (GPLv3).
 */

#include "base_defs.h"
#include "sys_defs.h"
#include "def.h"

void base_defs() {
EOF
foreach my $s (@d) {
    my @x = @$s;
    my $n = shift @x;
    my $p = join(',',@x);
    print $cfh "  $fmap{$n}($p);\n";
}

print $cfh <<EOF;
}
EOF


print $hfh <<'EOF';
/**
 * @ingroup def
 *
 * @file base_defs.h
 * @brief auto-generated system definitions
 *
 * NOTE: this file is auto-generated by base_defs.pl
 *
 * @copyright Copyright (C) 2013-2015, The MetaCurrency Project (Eric Harris-Braun, Arthur Brock, et. al).  This file is part of the Ceptr platform and is released under the terms of the license contained in the file LICENSE (GPLv3).
 */

#ifndef _CEPTR_BASE_DEFS_H
#define _CEPTR_BASE_DEFS_H
#include "sys_defs.h"

void base_defs();

EOF

&hout("Symbol");
&hout("Structure");
&hout("Process");

sub hout {
    my $type = shift;
    my $types = $type eq "Process" ? "Processes" : $type."s";
    my $a = $d{$type};
    print $hfh <<EOF;
enum System${\($type)}IDs {
    NULL_${\(uc($type))}_ID,
EOF
    foreach my $s (@$a) {
        print $hfh '    '.$s->[0]."_ID,\n";

    }
    print $hfh "    NUM_SYS_".uc($types)."\n};\n";
    foreach my $s (@$a) {
        print $hfh '#define '.$s->[0].' G_contexts[SYS_CONTEXT].'.lc($types).'['.$s->[0]."_ID]\n";
    }
}
print $hfh <<EOF;
#endif
EOF
